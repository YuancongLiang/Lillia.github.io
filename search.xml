<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Any Deep ReLU Network is Shallow论文笔记</title>
      <link href="/Lillia.github.io/2023/07/26/2023-7-26-any-deep-relu-network-is-shallow-lun-wen-bi-ji/"/>
      <url>/Lillia.github.io/2023/07/26/2023-7-26-any-deep-relu-network-is-shallow-lun-wen-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="论文链接"><a href="#论文链接" class="headerlink" title="论文链接"></a>论文链接</h2><p><a href="https://arxiv.org/pdf/2306.11827.pdf">arxiv.org/pdf/2306.11827.pdf</a></p><h2 id="论文简介"><a href="#论文简介" class="headerlink" title="论文简介"></a>论文简介</h2><p>这篇文章是一篇偏神经网络理论的文章，指出任何的深度<script type="math/tex">ReLU</script>网络都可以重写成一个功能相同的的三层网络，与万能逼近定理不一样的是，这个构造是无误差的，他们是完全等价的。</p><h2 id="整体思路"><a href="#整体思路" class="headerlink" title="整体思路"></a>整体思路</h2><p>在介绍整体思路之前，需要简单介绍一下前人的工作，总的来说就是一句话：<script type="math/tex">ReLU</script>网络可以表示为局部线性模型的集合，简单地说<script type="math/tex">ReLU</script>网络就是一个很多个区域的分段函数，每个区域的函数都是线性函数。</p><p>例如，一个<script type="math/tex">ReLU</script>网络可以表示成这样：</p><p>(如果没有特别说明，后续的<script type="math/tex">x</script>均视作输入向量)</p><script type="math/tex; mode=display">f(x)=\begin{cases}\Lambda_1(x) ,x\in \omega_1\\\Lambda_2(x) ,x\in \omega_2\\\Lambda_3(x) ,x\in \omega_3\end{cases}</script><p>首先，我们将解空间分割为<script type="math/tex">\omega_1,\omega_2,\omega_3</script>三个区域，对应的函数分别是<script type="math/tex">\Lambda_1(x),\Lambda_2(x),\Lambda_3(x)</script>。接着，我们对这里进行一点点的改写</p><script type="math/tex; mode=display">f(x)=\begin{cases}1 \cdot\Lambda_1(x)+0 \cdot \Lambda_2(x)+0 \cdot \Lambda_3(x),x\in \omega_1\\0 \cdot\Lambda_1(x)+1 \cdot \Lambda_2(x)+0 \cdot \Lambda_3(x),x\in \omega_2\\0 \cdot\Lambda_1(x)+0 \cdot \Lambda_2(x)+1 \cdot \Lambda_3(x),x\in \omega_3\end{cases}</script><p>我们改写成这样的原因是，这是函数的线性组合，我们可以通过向量写成一个更紧凑的形式：</p><script type="math/tex; mode=display">f(x)=\begin{cases}\begin{matrix}[1 & 0 & 0]\end{matrix}   \left[ \begin{matrix}   \Lambda_1(x) \\   \Lambda_2(x) \\   \Lambda_3(x)  \end{matrix}  \right],x\in \omega_1\\\begin{matrix}[0 & 1 & 0]\end{matrix}   \left[ \begin{matrix}   \Lambda_1(x) \\   \Lambda_2(x) \\   \Lambda_3(x)  \end{matrix}  \right],x\in \omega_2\\\begin{matrix}[0 & 0 & 1]\end{matrix}   \left[ \begin{matrix}   \Lambda_1(x) \\   \Lambda_2(x) \\   \Lambda_3(x)  \end{matrix}  \right],x\in \omega_3\\\end{cases}</script><p>我们不妨把前面的系数向量称作<strong>选择向量</strong>，毕竟它将我们希望的函数给挑选出来了。</p><p>好吧，但我们还是很讨厌分段函数，如果说，我们能找到一个函数<script type="math/tex">P(x)</script>，他能根据<script type="math/tex">x</script>所在的区域，给出我们所希望的<strong>选择向量</strong>，那么我们将能得到一个非常紧凑的形式：</p><script type="math/tex; mode=display">f(x)=P(x)\Lambda(x)\\which \;\; \Lambda(x)= \left[ \begin{matrix}   \Lambda_1(x) \\   \Lambda_2(x) \\   \Lambda_3(x)  \end{matrix}  \right],P(x)=\begin{cases}\begin{matrix}[1 & 0 & 0]\end{matrix},x\in \omega_1\\\begin{matrix}[0 & 1 & 0]\end{matrix},x\in \omega_2\\\begin{matrix}[0 & 0 & 1]\end{matrix},x\in \omega_3\end{cases}</script><p>而这就是这篇论文等价表述的思想，<strong>用矩阵描述代替分段函数</strong>。</p><p>但这里有两个问题很关键，首先，我们能否精准表示出<script type="math/tex">\Lambda(x)</script>。</p><p>在论文中，作者给出了前人的工作，在<strong>“ReLU Deep Neural Networks from the Hierarchical Basis Perspective”</strong>文章中，证明了实空间紧致子空间上的每一个分段线性函数都可以用一个深度和宽度都有限的神经网络精确表示。</p><p>其次，如果要根据<script type="math/tex">x</script>所在的区域，给出我们所希望的<strong>选择向量</strong>，那么我们就需要有一套有效的描述区域的手段。</p><p>作者也给出了相应的内容，在<strong>“Unwrapping the black box of deep relu networks: interpretability, diagnostics, and simplification”</strong>中，有提到对于每一个区域，都是一个多胞体，它可以被定义为有限个线性不等式的结集，即有限个半平面的交集。因此我们可以通过描述半空间，来判断<script type="math/tex">x</script>所在的区域。</p><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><h3 id="第一个构造"><a href="#第一个构造" class="headerlink" title="第一个构造"></a>第一个构造</h3><p>A polytope can be specified the entire partition by a set of half-space. In particular, let  <script type="math/tex">\omega_1,...,\omega_k</script> be the the minimum set of half-spaces that specify all the partition, where each <script type="math/tex">\omega_i</script> is an inequalities describing a half space such that:</p><p>一个多胞体可以由一组半空间指定整个分区。特别地，我们令<script type="math/tex">P_1,...,P_k</script>是声明所有分区的最小半空间集合，其中<script type="math/tex">P_i</script>是一条描述半空间的不等式。</p><script type="math/tex; mode=display">h_{i,1}x_1 + h_{i,2}x_2 + ... + h_{i,n}x_n > c_i</script><p>Or rewrite it into more of the form we will see later:</p><p>或者改写成我们一会见得更多的形式：</p><script type="math/tex; mode=display">-h_{i,1}x_1 - h_{i,2}x_2 - ... - h_{i,n}x_n + c_i < 0</script><p>换句话说，所有分区都可以写成<script type="math/tex">P_1,...,P_k</script>中某几个半空间的交集。</p><p>我们先找到一个矩阵<script type="math/tex">\Psi</script>能够储存所有的超平面方程：</p><script type="math/tex; mode=display">\Psi(x)=Hx+c=\left[ \begin{matrix}   -h_{1,1} & -h_{1,2} & ... & -h_{1,n}\\   -h_{2,1} & -h_{2,2} & ... & -h_{2,n} \\   ... & & & ...\\   -h_{k,1} & -h_{k,2} & ... & -h_{k,n}  \end{matrix}  \right]  \left[ \begin{matrix}   x_1 \\   x_2 \\   ... \\   x_n  \end{matrix}  \right]+  \left[  \begin{matrix}   c_1 \\   c_2 \\   ... \\   c_k  \end{matrix}  \right]</script><p>或者写成一个：</p><script type="math/tex; mode=display">\Psi(x)=\left[ \begin{matrix}   -h_{1,1}\cdot x_1-h_{1,2}\cdot x_2- ... -h_{1,n}\cdot x_n+c_1\\   -h_{2,1}\cdot x_1-h_{2,2}\cdot x_2- ... -h_{2,n}\cdot x_n+c_2\\   ...\\   -h_{k,1}\cdot x_1-h_{k,2}\cdot x_2- ... -h_{k,n}\cdot x_n+c_k  \end{matrix}  \right]</script><p>数学上一般将<script type="math/tex">-h_{i,1}x_1 - h_{i,2}x_2 - ... - h_{i,n}x_n + c_i = 0</script>这个式子称为超平面。</p><p>这样，矩阵方程<script type="math/tex">\Psi(x)=O</script>每一行都唯一描述了一个超平面方程。</p><p>我们现在假设空间上有一个点<script type="math/tex">x</script>，它所在的空间恰好可以由<script type="math/tex">P_1,P_2,P_5</script>三个半空间交集而成。</p><p>这意味着他将同时满足下面三条不等式：</p><script type="math/tex; mode=display">-h_{1,1}x_1 - h_{1,2}x_2 - ... - h_{1,n}x_n + c_1 < 0\\-h_{2,1}x_1 - h_{2,2}x_2 - ... - h_{2,n}x_n + c_2 < 0\\-h_{5,1}x_1 - h_{5,2}x_2 - ... - h_{5,n}x_n + c_5 < 0</script><p>这也意味着<script type="math/tex">\Psi(x)</script>至少第一、二、五行都是小于<script type="math/tex">0</script>的。（也可能有其他行也是小于<script type="math/tex">0</script>的，因为这个点<script type="math/tex">x</script>可能也处在其他半空间内，但是对于我们需要的分区，并不需要其他的半空间参与进来了）</p><p>由于<script type="math/tex">\Psi(x)</script>至少第一、二、五行都是小于<script type="math/tex">0</script>的，因此<script type="math/tex">ReLU(\Psi(x))</script>至少第一、二、五行都是等于<script type="math/tex">0</script>的。</p><p>到这一步，我们至少把<script type="math/tex">x</script>所在的半空间条件给挑出来了。</p><p>但是，就像我们所说的，我们并不能确定他保证它<script type="math/tex">\Psi(x)</script>其他行有小于<script type="math/tex">0</script>的情况出现，也就是说，<script type="math/tex">\Psi(x)</script>有可能还保留了一些我不需要的半空间条件，我们需要在第二个构造里消除它。</p><h3 id="第二个构造"><a href="#第二个构造" class="headerlink" title="第二个构造"></a>第二个构造</h3><p>就像一开始提到的<strong>选择向量</strong>一样，我们在这里也需要一个<strong>选择矩阵</strong>。不妨设这个矩阵为<script type="math/tex">R</script>，我们希望的结果是，对于<script type="math/tex">R\cdot ReLU(\Psi(x))</script>，它能够将分区的超平面方程挑选出来。</p><p>我们现在考虑第<script type="math/tex">j</script>个分区，它恰好可以由<script type="math/tex">P_1,P_2,P_5</script>三个半空间交集而成。则我们可以考虑矩阵<script type="math/tex">R</script>的第<script type="math/tex">j</script>行为：</p><script type="math/tex; mode=display">\left[ \begin{matrix}   1 & 1 & 0 & 0 & 1 & 0 & ...  \\  \end{matrix}  \right]</script><p>仅有第一、二、五列为<script type="math/tex">1</script>，其余都为<script type="math/tex">0</script>。</p><p>则有<script type="math/tex">[R\cdot ReLU(\Psi(x))]_j=R_j\cdot ReLU(\Psi(x))\\</script>。</p><p>即<script type="math/tex">R\cdot ReLU(\Psi(x))</script>的第<script type="math/tex">j</script>行等于<script type="math/tex">R</script>的第<script type="math/tex">j</script>行乘上<script type="math/tex">ReLU(\Psi(x)</script>。</p><p>（我们还是举个例子）</p><script type="math/tex; mode=display">\left[ \begin{matrix}   &&&...\\   1 & 1 & 0 & 0 & 1 & 0 & ...\\   &&&...  \end{matrix}  \right]  ReLU(\left[ \begin{matrix}   -h_{1,1}\cdot x_1-h_{1,2}\cdot x_2- ... -h_{1,n}\cdot x_n+c_1\\   -h_{2,1}\cdot x_1-h_{2,2}\cdot x_2- ... -h_{2,n}\cdot x_n+c_2\\   ...\\   -h_{k,1}\cdot x_1-h_{k,2}\cdot x_2- ... -h_{k,n}\cdot x_n+c_k  \end{matrix}  \right])</script><p>最终结果是</p><script type="math/tex; mode=display">ReLU(-h_{1,1}x_1 - h_{1,2}x_2 - ... - h_{1,n}x_n + c_1)+\\ReLU(-h_{2,1}x_1 - h_{2,2}x_2 - ... - h_{2,n}x_n + c_2)+\\ReLU(-h_{5,1}x_1 - h_{5,2}x_2 - ... - h_{5,n}x_n + c_5)\\</script><p>假如我们的<script type="math/tex">x</script>恰好处在第<script type="math/tex">j</script>个分区，我们会发现，<script type="math/tex">R\cdot ReLU(\Psi(x))</script>的第<script type="math/tex">j</script>行恰好就是<script type="math/tex">0</script>。由于我们的<script type="math/tex">P_1,...,P_k</script>是声明所有分区的最小半空间集合，所以不可能出现同时有两行出现<script type="math/tex">0</script>，否则就意味着我们的<script type="math/tex">x</script>它同时处于两个不同的分区，又或者说，处在两个分区的交集上，这样它的半空间集合就不可能是最小的。（我们完全可以将交集部分单独划分成一个新的分区）。</p><h3 id="第三个构造"><a href="#第三个构造" class="headerlink" title="第三个构造"></a>第三个构造</h3><p>我们在这一步会引入一个拓展实数<script type="math/tex">\infin</script>，在数学上这样的拓展实数系代数性质很差，因为两个无穷大相除是没有结果的。但是我们在这里并不关心这件事，我们只引入两个基本的运算即可：</p><script type="math/tex; mode=display">0 \cdot \infin = 0\\a \cdot \infin = \infin,for \; a\in R</script><p>幸运的是在Python中包含这样的一个常量，用<script type="math/tex">inf</script>表示。</p><p>我们引入一个函数矩阵<script type="math/tex">\Lambda(x)=\alpha^T x+\beta</script>，不妨假定它一共有<script type="math/tex">p</script>行。它的第<script type="math/tex">j</script>行表示第<script type="math/tex">j</script>个分区的对应的线性函数。则有：</p><script type="math/tex; mode=display">\Lambda(x) - \infin \cdot ReLU(R\cdot ReLU(\Psi(x))) =\left[ \begin{matrix}   -\infin\\   ...\\   -\infin\\   \Lambda(x)_j\\   -\infin\\   ...\\   -\infin  \end{matrix}  \right]</script><p>根据我们上面提到的运算，只有第<script type="math/tex">j</script>行才不为<script type="math/tex">-\infin</script>，而是对应的<script type="math/tex">\Lambda(x)_j</script>。</p><p>此时只需要经过一次<script type="math/tex">ReLU</script>即可将<script type="math/tex">-\infin</script>全部消除。</p><p>但实际上我们并不知道<script type="math/tex">\Lambda(x)_j</script>是否大于0。如果它小于0，那么经过<script type="math/tex">ReLU</script>以后也变成0了。因此我们构造的是：</p><script type="math/tex; mode=display">ReLU(\left[ \begin{matrix}\Lambda(x) - \infin \cdot ReLU(R\cdot ReLU(\Psi(x)))\\-\Lambda(x) - \infin \cdot ReLU(R\cdot ReLU(\Psi(x))) \end{matrix}  \right])</script><p>这是一个<script type="math/tex">2p</script>行的向量，其中，要么是第<script type="math/tex">j</script>行为<script type="math/tex">0</script>，要么是第<script type="math/tex">p+j</script>行为<script type="math/tex">0</script>，已经无所谓了，我们只需要构造一个行向量<script type="math/tex">W</script>，<script type="math/tex">1</script>到<script type="math/tex">p</script>列为<script type="math/tex">1</script>，<script type="math/tex">p</script>到<script type="math/tex">2p</script>列为<script type="math/tex">-1</script>，则有：</p><script type="math/tex; mode=display">W \cdot ReLU(\left[ \begin{matrix}\Lambda(x) - \infin \cdot ReLU(R\cdot ReLU(\Psi(x)))\\-\Lambda(x) - \infin \cdot ReLU(R\cdot ReLU(\Psi(x))) \end{matrix}  \right])=\Lambda(x)</script><p>到这一步，我们就已经构造出来我们希望的东西了，只要我们找到<script type="math/tex">H,c,\alpha,\beta</script>，那么我们就可以利用刚才的构造，找到一个与原网络完全等价的一个浅层网络了。</p><p>（在论文里，作者对于第三个构造有一些数学上的考虑，但是这是很trivial的）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CAM论文解读</title>
      <link href="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/"/>
      <url>/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/</url>
      
        <content type="html"><![CDATA[<h2 id="论文链接"><a href="#论文链接" class="headerlink" title="论文链接"></a>论文链接</h2><p><a href="https://arxiv.org/pdf/1512.04150.pdf">Learning Deep Features for Discriminative Localization (arxiv.org)</a></p><h2 id="CAM简介"><a href="#CAM简介" class="headerlink" title="CAM简介"></a>CAM简介</h2><p>Class Activation Mapping（CAM）是一种用于可视化和解释卷积神经网络（CNN）对于输入图像中不同类别的关注程度的方法。</p><p>在传统的CNN中，我们通过多个卷积层和池化层，最后通过全连接层进行分类。CAM的思想是，通过观察卷积层的特征图，可以了解到哪些区域对于分类结果的贡献更大。</p><h2 id="特征图"><a href="#特征图" class="headerlink" title="特征图"></a>特征图</h2><p>在讲具体的数学推导以前，我们先看一下resnet50的卷积特征图：</p><h3 id="原图-1-3-224-224"><a href="#原图-1-3-224-224" class="headerlink" title="原图[1,3,224,224]"></a>原图[1,3,224,224]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720132725543.png" class=""><h3 id="conv1-1-64-112-112"><a href="#conv1-1-64-112-112" class="headerlink" title="conv1 [1,64,112,112]"></a>conv1 [1,64,112,112]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/f1_conv1.png" class=""><h3 id="bn1-relu-1-64-112-112"><a href="#bn1-relu-1-64-112-112" class="headerlink" title="bn1_relu [1,64,112,112]"></a>bn1_relu [1,64,112,112]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720132858679.png" class=""><h3 id="maxpool-1-64-56-56"><a href="#maxpool-1-64-56-56" class="headerlink" title="maxpool [1,64,56,56]"></a>maxpool [1,64,56,56]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720133051924.png" class=""><h3 id="layer1-1-256-56-56"><a href="#layer1-1-256-56-56" class="headerlink" title="layer1 [1,256,56,56]"></a>layer1 [1,256,56,56]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720133104802.png" class=""><h3 id="layer2-1-512-28-28"><a href="#layer2-1-512-28-28" class="headerlink" title="layer2 [1,512,28,28]"></a>layer2 [1,512,28,28]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720133146434.png" class=""><h3 id="layer3-1-1024-14-14"><a href="#layer3-1-1024-14-14" class="headerlink" title="layer3 [1,1024,14,14]"></a>layer3 [1,1024,14,14]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720133209777.png" class=""><h3 id="layer4-1-2048-7-7"><a href="#layer4-1-2048-7-7" class="headerlink" title="layer4 [1,2048,7,7]"></a>layer4 [1,2048,7,7]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720133232968.png" class=""><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720133245792.png" class=""><h3 id="avgpool-1-2048"><a href="#avgpool-1-2048" class="headerlink" title="avgpool [1,2048]"></a>avgpool [1,2048]</h3><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720133304206.png" class=""><p>layer4的输出是这样的<script type="math/tex">[1,2048,7,7]</script>的特征图，总而言之，我们在resnet50最后一个卷积层出来的结果就是<script type="math/tex">2048</script>个<script type="math/tex">7*7</script>的图像。</p><p>我们用<script type="math/tex">f_k(x,y)</script>来表示第<script type="math/tex">k</script>张图的图像矩阵。</p><p>在经过了一系列卷积层的特征提取以后，resnet50会将这些图片进行全局平均池化（GlobalAvgPool）</p><script type="math/tex; mode=display">\text{GlobalAvgPool}(F_k) = \frac{1}{W \times H} \sum_{x=1}^{W} \sum_{y=1}^{H} f_k(x,y)=\frac{1}{W \times H}\sum_{x,y}f_k(x,y)</script><p>这样我们就得到了一个<script type="math/tex">[1,2048]</script>的特征向量（我们先这么称呼它），最终我们通过一个全连接层，进行分类。</p><h2 id="数学推导"><a href="#数学推导" class="headerlink" title="数学推导"></a>数学推导</h2><p>对于一个分类问题，给定一个类A，我们希望找到对于类A而言，哪一部分的图像对类A的得分贡献最大。</p><p>对于类A而言，其全连接层的输出为类A的得分<script type="math/tex">S_A=\sum_k{}F_k \omega^{k}\!_A</script>，将<script type="math/tex">F_k</script>代入进去，有</p><script type="math/tex; mode=display">S_A=\frac{1}{W \times H}\sum_k{}\sum_{x,y}f_k(x,y) \omega^{k}\!_A\\\ \ \ \ =\frac{1}{W \times H}\sum_{x,y}\sum_k{}f_k(x,y) \omega^{k}\!_A</script><p>定义类激活图函数<script type="math/tex">M_A</script>:</p><script type="math/tex; mode=display">M_A(x,y)=\sum_k{}f_k(x,y) \omega^{k}\!_A</script><p>这里的<script type="math/tex">M_A</script>是一个<script type="math/tex">7*7</script>的图像矩阵，空间网格的值越大，就说明该网格对应的部分区域对<script type="math/tex">S_A</script>的贡献越大，换句话说，在分类任务中，这片区域经过卷积提取的特征对A而言更重要。</p><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720131249407.png" class=""><p>一般来说，我们只需要找到我们要关注的那个类，找到它的类激活函数<script type="math/tex">M(x,y)</script>，最后我们插值resize回去，再叠加在原图上就能得到一个类激活热图了。</p><img src="/Lillia.github.io/2023/07/19/2023-7-19-cam-lun-wen-jie-du/image-20230720132043110.png" class="">]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读论文 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL安装</title>
      <link href="/Lillia.github.io/2023/05/20/wsl-an-zhuang/"/>
      <url>/Lillia.github.io/2023/05/20/wsl-an-zhuang/</url>
      
        <content type="html"><![CDATA[<p>首先是上来先打开Linux子系统支持。</p><img src="/Lillia.github.io/2023/05/20/wsl-an-zhuang/image-20230520205932720.png" class="" title="image-20230520205932720"><p>Hyper-V，适用于Linux的Windows子系统，虚拟机平台打勾</p><p>打开Hyper-V以后锐捷用不了</p><pre class="line-numbers language-powershell" data-language="powershell"><code class="language-powershell">dism<span class="token punctuation">.</span>exe <span class="token operator">/</span>online <span class="token operator">/</span><span class="token function">enable-feature</span> <span class="token operator">/</span>featurename:Microsoft-Windows-Subsystem-Linux <span class="token operator">/</span>all <span class="token operator">/</span>norestart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-text" data-language="text"><code class="language-text">dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>上不了网可能是Hyper-V开了手动代理，但具体不清楚，可能要手动关。</p><img src="/Lillia.github.io/2023/05/20/wsl-an-zhuang/image-20230520210211136.png" class="" title="image-20230520210211136"><p>然后去这里下载WSL2支持：<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi</a></p><p>好像在微软商店也可以。</p><p>然后微软商店弄个Ubuntu，下载打开。</p><p>然后在VSCode里面装个WSL插件，连接一下服务器</p><img src="/Lillia.github.io/2023/05/20/wsl-an-zhuang/image-20230520212754439.png" class="" title="image-20230520212754439"><p>然后弄个清华源。</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">ubuntu | 镜像站使用帮助 | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>然后更新git信息</p><p>git config —global user.name “DidUSeeMyElk” </p><p>git config —global user.email “1035603730@qq.com”</p><p>然后是ssh密钥</p><p>ssh-keygen -t rsa -C “1035603730@qq.com”</p><p>然后放到github</p><p>然后安装anaconda</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/?C=M&amp;O=D">Index of /anaconda/archive/ | 清华大学开源软件镜像站 | Tsinghua Open Source Mirror</a></p><p>wget <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.03-1-Linux-x86_64.sh">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2023.03-1-Linux-x86_64.sh</a></p><p>bash Anaconda3-2023.03-1-Linux-x86_64.sh</p><p>不断回车</p><p>遇到用户协议按一下q</p><p>vim ~/.bashrc</p><p>在最下方加入export PATH=”/home/elk/anaconda3/bin:$PATH”</p><p>然后esc，:wq</p><p>source ~/.bashrc</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备忘录 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道可以用群论的算法</title>
      <link href="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/"/>
      <url>/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一道leetcode上的题目：</p><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><a href="https://leetcode.cn/leetbook/read/top-interview-questions-easy/x2skh7/">初级算法 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p><p><strong>示例 :</strong></p><blockquote><p>输入: nums = <script type="math/tex">[1,2,3,4,5,6,7]</script>, <script type="math/tex">k = 3</script><br>输出: <script type="math/tex">[5,6,7,1,2,3,4]</script><br>解释:<br>向右轮转 1 步: <script type="math/tex">[7,1,2,3,4,5,6]</script><br>向右轮转 2 步: <script type="math/tex">[6,7,1,2,3,4,5]</script><br>向右轮转 3 步: <script type="math/tex">[5,6,7,1,2,3,4]</script></p></blockquote><p>显而易见这是一种轮换，但可能是多次轮换，它不改变数组本身，只改变元素的位置。也就是说，这是一个置换。</p><p>先回忆下一个置换的写法：</p><blockquote><p>设<script type="math/tex">\varphi</script>是n元集合<script type="math/tex">M=\{a_{1},a_{2},...a_{n}\}</script>上的一个双射置换，为了简单记为<script type="math/tex">M=\{1,2,...,n\}</script>。令<script type="math/tex">\varphi=\left(\begin{matrix}1&2&...&n\\\varphi(1)&\varphi(2)&...&\varphi(n)\end{matrix}\right)</script>表示<script type="math/tex">M</script>上的一个置换，第一行表示原象，第二行表示像的集合。</p></blockquote><p>我们可以写出示例中的置换群表示：</p><script type="math/tex; mode=display">\varphi=\left(\begin{matrix}1&2&3&4&5&6&7\\5&6&7&1&2&3&4\end{matrix}\right)</script><p>也就是把1号位的换成5号位的，把2号位的换成6号位的，3号位的换成7号位的，依此类推。</p><p>这个置换是直观的，也是容易理解的，我们很容易就有了第一种想法。</p><h2 id="算法尝试"><a href="#算法尝试" class="headerlink" title="算法尝试"></a>算法尝试</h2><h3 id="置换表示"><a href="#置换表示" class="headerlink" title="置换表示"></a>置换表示</h3><p>置换是非常直观的方法，但问题是，如果我直接把1号位的元素换成5号位的，那我就必须将1号位的元素放在一个临时变量里，否则直接赋值的话，1号位的元素就被覆盖了。</p><p>我们可以使用一个临时数组，先把原数组的值存放到一个临时数组中，然后再把临时数组的值重新赋给原数组，重新赋值的时候要保证每个元素都要往后移k位，如果超过数组的长度就从头开始，所以这里可以使用(i + k) % length来计算重新赋值的元素下标。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427150039954.png" class="" title="置换表示原理"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> temp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment">//把原数组值放到一个临时数组中，</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//然后在把临时数组的值重新放到原数组，并且往右移动k位</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        nums<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427165003533.png" class="" title="算法评估"><h3 id="轮换表示"><a href="#轮换表示" class="headerlink" title="轮换表示"></a>轮换表示</h3><p>相信不用我说都看出来了，如果这个数组特别大的时候，这样做的内存消耗是很大的。</p><p>但是众所周知，一般的置换表示可以写成轮换表示。</p><blockquote><p>定义：一个置换<script type="math/tex">\sigma</script>如果把数码<script type="math/tex">i_{1}</script>变成<script type="math/tex">i_{2}</script>，<script type="math/tex">i_{2}</script>变成<script type="math/tex">i_{3}</script>，…，<script type="math/tex">i_{k-1}</script>变成<script type="math/tex">i_{k}</script>，<script type="math/tex">i_{k}</script>又变成<script type="math/tex">i_{1}</script>，而使得其余的元（假如还有的话）都不变，则称<script type="math/tex">\sigma</script>为一个k-轮换（循环）置换。记为：<script type="math/tex">\sigma=(i_{1}i_{2}...i_{k})=(i_{2}i_{3}...i_{k}i_{1})=...=(i_{k}i_{1}...i_{k-1})</script></p><p>注：2-轮换简称为对换。恒等映射通常记为（1）</p></blockquote><p>我们把上文示例的置换表示改写成轮换：<script type="math/tex">\varphi=(1473625)</script></p><p>实际上，有定理保证，对于每个置换都可以写成若干个不相连的轮换之积，因此这种写法总是可行的。</p><p>我们观察轮换元的规律，似乎是将数组视作一个环形，1号位向右移3位到达4号位，4号位向右移3位到达7号位，7号位向右移3位到达10号位，由于最后一个与第一个相连，因此8号位就是1号位，10号位就是3号位。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427162843085.png" class=""><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427162911018.png" class="" title="轮换表示原理"><p>依照这个思路，我们可以写出轮换表示的算法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> hold <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">+</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果访问过，再次访问的话，会出现原地打转的现象，</span>            <span class="token comment">//不能再访问当前元素了，我们直接从他的下一个元素开始</span>            index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">;</span>            hold <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//把当前值保存在下一个位置，保存之前要把下一个位置的</span>            <span class="token comment">//值给记录下来</span>            visited<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>            nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hold<span class="token punctuation">;</span>            hold <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是，如果数组长度length和轮换步长k不互质的话，将会在某一次轮换后回到原点。因此保留了一个数组visited表示这个元素有没有被访问过，如果被访问过就从他的下一个开始，防止原地打转。</p><p>此时意味着该置换群不止一个不相连轮换。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427163259739.png" class="" title="算法评估"><h3 id="对换表示"><a href="#对换表示" class="headerlink" title="对换表示"></a>对换表示</h3><p>我们还是希望在轮换的基础上更进一步。一般的置换方法中，我们需要有一个大的临时数组，一般来说会带来很大的内存消耗。轮换方法中，数组的下标需要依赖大量的求余运算，这种运算总是更耗时的。</p><p>如果我们可以找到一个简单的方法，通过对换就能实现算法，那应该既能避免大的内存消耗，也能够节省时间。我们来看看chatGPT和leetcode给的答案。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    k <span class="token operator">%=</span> length<span class="token punctuation">;</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先反转全部的元素</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在反转前k个元素</span>    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//接着反转剩余的</span><span class="token punctuation">}</span><span class="token comment">//把数组中从[start，end]之间的元素两两交换,也就是反转</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>start<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>end<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>leetcode和chatGPT给出的答案都是利用翻转实现的。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427170714697.png" class="" title="翻转算法原理"><p>当然，大家都知道，反转无非就是一前一后的数组元素进行对换。也就是说反转给出的算法其实正是对换操作。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427171137854.png" class="" title="算法评估"><h2 id="对换与轮换"><a href="#对换与轮换" class="headerlink" title="对换与轮换"></a>对换与轮换</h2><p>显而易见地，对换方法在时间上有着得天独厚的优势。但我们在这里讨论一点更数学的问题。</p><p>假如我们采用翻转的方法去实现功能，我们需要对数组元素进行对换操作。我想谈论的问题是：</p><p>1、翻转方法中，至多几次对换操作，就能够保证对所有情况都能达到预期效果。</p><p>答案：<script type="math/tex">n</script>次。（<script type="math/tex">n</script>为数组长度）</p><p>2、至少几次对换操作，才能够保证对所有情况都能达到预期效果。</p><p>答案：<script type="math/tex">n-1</script>次。（<script type="math/tex">n</script>为数组长度）</p><p>（第二问的意思是，如果你只能进行<script type="math/tex">n-2</script>次对换操作，那么无论你怎样优化算法，总有数组你无法达到预期效果）</p><p>第一问的答案是容易证明的。</p><blockquote><p>证明：共进行了三次翻转，第一次对数组<script type="math/tex">n</script>个元素进行翻转，第二次对数组前<script type="math/tex">k</script>个元素进行翻转，第三次对数组后<script type="math/tex">n-k</script>个元素进行翻转。</p><p>容易证明对i个元素的数组进行翻转需要<script type="math/tex">[\frac{i}{2}]</script>次对换，则总共需要<script type="math/tex">[\frac{n}{2}]+[\frac{k}{2}]+[\frac{n-k}{2}]</script>次对换</p><p>注意到<script type="math/tex">k+(n-k)=n</script>，因此，<script type="math/tex">k,n-k,n</script>不可能同时为奇数，也不可能只有两个偶数，因此只有两种情况，两奇一偶，三偶。</p><p>三者都为偶数时，取整号可以直接拆掉，此时共<script type="math/tex">n</script>次对换。</p><p>两个为奇数，一个为偶数时，可将其改写成<script type="math/tex">[x]=x-\{x\}</script>，且此时<script type="math/tex">\{x\}=\frac{1}{2}</script>，此时共<script type="math/tex">n-1</script>次对换。</p><p>因此至多<script type="math/tex">n</script>次对换。</p></blockquote><p>第二问需要借助两个置换群的定理。</p><blockquote><p><strong>定理1</strong>：任何一个<strong>轮换</strong>都可以表示为若干个<strong>对换</strong>的乘积，且<strong>对换数</strong>等于<script type="math/tex">元素个数-1</script>。比如：</p><script type="math/tex; mode=display">\left(\begin{matrix}a&b&c&d&e&f\end{matrix}\right)=\left(\begin{matrix}a&b\end{matrix}\right)\left(\begin{matrix}b&c\end{matrix}\right)\left(\begin{matrix}c&d\end{matrix}\right)\left(\begin{matrix}d&e\end{matrix}\right)\left(\begin{matrix}e&f\end{matrix}\right)</script><p>按从右向左的运算原则，显然有：</p><script type="math/tex; mode=display">f\rightarrow e\rightarrow d\rightarrow c\rightarrow b\rightarrow a=f\rightarrow a</script><p>其他，<script type="math/tex">e\rightarrow f,d\rightarrow e,...,a\rightarrow b</script>保持不变，因此定理1成立。</p><p><strong>定理2：</strong>将一个置换分解为不相交轮换的乘积，如果不考虑因子的次序和乘积中1轮换的个数，则这个分解式是唯一的。</p><p>可以将每一个轮换都看作一个圆，这个圆和其他圆不相交，这个圆上的点做任何拓扑上的改变都会导致置换的结果发生变化，因此置换的分解公式是唯一的。</p><p><strong>定理3：</strong>每个置换都可以表示为对换的乘积。</p><p>根据定理2，<strong>每个置换分解为唯一的不相交轮换的乘积</strong>，每个轮换可以分解为对换的乘积。因此每个置换都可以表示为对换的乘积。</p></blockquote><p>下面我们就可以开始证明了：</p><blockquote><p>以下证明默认<script type="math/tex">nums.length=n</script></p><p>证明：我们首先需要证明，对于题目中的全轮换<script type="math/tex">(123...n)</script>，当<script type="math/tex">0<k<n</script>时，其置换群的轮换表示必定包含<script type="math/tex">1</script>到<script type="math/tex">n</script>。</p><p>其实就是证明不存在数组某一元素位置没有发生改变，全轮换后，数组下标<script type="math/tex">i</script>（假设由1开始）将会变成<script type="math/tex">(i+k)\%n\neq i</script>。因此轮换表示必定包含所有元素。</p><p>先将置换分解为不相交轮换的乘积，设不相交轮换数为<script type="math/tex">i</script>，又定理1可知，一个轮换可以拆成<script type="math/tex">元素个数-1</script>个对换，因此总共有<script type="math/tex">n-i</script>个对换。</p><p>由于置换至少可以分解成一个不相交轮换，因此至少<script type="math/tex">n-1</script>次对换操作，才能够保证对所有情况都能达到预期效果。</p></blockquote><p>我们可以根据这个思路，将置换群转换为若干个对换的乘积，原则上说，是比翻转算法至少少一次对换。</p><p>当然，如果我们先写出置换群，在分解成轮换群，最后再分解成对换的乘积，这显然是不够效率的，所幸这题是一个全轮换群，全轮换群的乘积是非常容易计算的。</p><p>以下同样默认<script type="math/tex">nums.length=n</script>，则其中一个不相连轮换群乘积可表示成：</p><script type="math/tex; mode=display">\begin{matrix}(1&(1+k)\%n&(1+2k)\%n&...&(1+ik)\%n)\end{matrix}</script><p>其中，<script type="math/tex">0<i\leq n</script></p><p>我们在进行数组索引的时候，是从<script type="math/tex">0</script>开始的，因此，实际写代码的时候也不需要这个恼人的<script type="math/tex">1</script>了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>       k <span class="token operator">=</span> k<span class="token operator">%</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token class-name">Overlay</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">Overlay</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token keyword">int</span> index1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> index2<span class="token operator">=</span>k<span class="token punctuation">;</span>       <span class="token keyword">int</span> group_amount<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//群元数</span>       <span class="token keyword">int</span> total_length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//群元长度</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length <span class="token operator">&amp;</span> total_length<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           total_length<span class="token operator">++</span><span class="token punctuation">;</span>           index1<span class="token operator">=</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>           index2<span class="token operator">=</span><span class="token punctuation">(</span>index1<span class="token operator">+</span>length<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token operator">%</span>length<span class="token punctuation">;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>index2<span class="token operator">==</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   group_amount<span class="token operator">++</span><span class="token punctuation">;</span>                   <span class="token keyword">break</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token function">exchange</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>index1<span class="token punctuation">,</span>index2<span class="token punctuation">)</span><span class="token punctuation">;</span>               index1<span class="token operator">=</span>index2<span class="token punctuation">;</span>               index2<span class="token operator">=</span><span class="token punctuation">(</span>index2<span class="token operator">-</span>k<span class="token operator">+</span>length<span class="token punctuation">)</span><span class="token operator">%</span>length<span class="token punctuation">;</span>               total_length<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span>   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> temp<span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>       nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们唯一需要注意的也许是实际对换操作的时候，我们是右结合，因此是倒着生成对换群，倒着对换的。</p><p>数组最后一个元素的指标是<script type="math/tex">n-1</script>，因此我们还是看到了这个恼人的<script type="math/tex">1</script>。</p><p>这其实类似第二种方法，唯一不同的是，第二种方法通过visited数组避免重复索引，在这里，其实就是置换群分解成了多个不相连的轮换群，而我们只在其中一个轮换群中进行轮换。这里的方法是通过索引数组角标，当回到原点的时候，跳出循环。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427171208493.png" class="" title="算法评估"><p>好吧，是个负优化。还是跟第二个方法问题一样，索引脚标的时候出现了大量的求余计算。我们为了那一次的对换提升，花费了大量的运算。</p><p>但反过来说，我们从某种程度上证明了，如果我们只通过对换解决这个问题，那么翻转算法速度上就是最优解。因为它至多用了<script type="math/tex">n</script>次对换，而理论上限是<script type="math/tex">n-1</script>，但<script type="math/tex">n-1</script>次对换的算法需要大量求余。</p><h2 id="对换与翻转"><a href="#对换与翻转" class="headerlink" title="对换与翻转"></a>对换与翻转</h2><p>我们刚才说过翻转算法需要<script type="math/tex">n</script>或<script type="math/tex">n-1</script>次对换，而轮换分解则需要<script type="math/tex">n-i</script>次对换。</p><p>很自然我就有一些疑问，这个<script type="math/tex">i</script>能不能被事先求出来，他们的对应关系是怎么样的。</p><p>要解答这两个问题首先需要证明在第二个方法中提到的一句话：</p><blockquote><p>如果数组长度length和轮换步长k不互质的话，将会在某一次轮换后回到原点。</p></blockquote><p>事实上这句话的关键在于，如果数组长度length和轮换步长k不互质，那么至少存在两个或以上的不相连轮换群。</p><blockquote><p>以下证明默认<script type="math/tex">nums.length=n</script></p><p>证明：首先根据轮换群乘法，本问题中可能出现的置换群的一个不相连轮换群可表示成：</p><script type="math/tex; mode=display">\begin{matrix}(1&(1+k)\%n&(1+2k)\%n&...&(1+ik)\%n)\end{matrix}</script><p>有<script type="math/tex">((i+1)k)\%n=0</script></p><p>这是自然的，因为对于该轮换群，其对换过程为<script type="math/tex">1\rightarrow (1+k)\%n\rightarrow (1+2k)\%n\rightarrow ...\rightarrow (1+ik)\%n\rightarrow 1</script></p><p>如果<script type="math/tex">k</script>与<script type="math/tex">n</script>互质，则当且仅当<script type="math/tex">i+1=n</script>时成立，此时该不相连轮换群长度为<script type="math/tex">n</script>，已经包含了所有元素。数组中找不出与它不公共的元素，因此它是唯一的不相连轮换群。</p><p>因此当<script type="math/tex">k</script>与<script type="math/tex">n</script>不互质时，至少存在两个或以上的不相连轮换群。</p></blockquote><p>通过以上的证明我们能感受到，当<script type="math/tex">0<i\leq n</script>时，有几个<script type="math/tex">i</script>满足<script type="math/tex">(ik)\%n=0</script>，置换群就能分解成几个不相连轮换群的乘积。</p><p>但是大家会注意到如果<script type="math/tex">(jk)\%n=0</script>，那么<script type="math/tex">(2jk)\%n=0</script>同样满足，一直往上，并且<script type="math/tex">(nk)\%n=0</script>一定满足。因此<script type="math/tex">jk</script>应该是<script type="math/tex">n</script>和<script type="math/tex">k</script>的最小公倍数。此时，<script type="math/tex">i=\{j,2j,...,n-j,n\}</script>，一共有<script type="math/tex">\frac{n}{j}</script>个<script type="math/tex">i</script>。</p><p>翻转算法到底需要<script type="math/tex">n</script>次还是<script type="math/tex">n-1</script>次对换，取决于他们的奇偶分布，轮换分解则需要<script type="math/tex">n-i</script>次对换，<script type="math/tex">i</script>与<script type="math/tex">n</script>和<script type="math/tex">k</script>的最小公倍数有关，因此两者并不能直接建立起联系。</p><p>但是他们还是有点关系的，参考下面的定理。</p><blockquote><p><strong>定理4</strong>：虽然一个置换表示成对换的个数不唯一，但所用对换个数的奇偶性是唯一的。</p></blockquote><p>翻转算法需要<script type="math/tex">n</script>次对换时，<script type="math/tex">n</script>和<script type="math/tex">k</script>都必须是偶数，此时<script type="math/tex">n</script>和<script type="math/tex">k</script>不互质，因此存在两个或以上的不相连轮换群，所以<script type="math/tex">i</script>必须也会偶数。这样，<script type="math/tex">n</script>和<script type="math/tex">n-i</script>就都是偶数了。<script type="math/tex">n-1</script>次的情况同理。</p>]]></content>
      
      
      <categories>
          
          <category> 群论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 群论 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录下tensorRT的部署</title>
      <link href="/Lillia.github.io/2023/02/18/ji-lu-xia-tensorrt-de-bu-shu/"/>
      <url>/Lillia.github.io/2023/02/18/ji-lu-xia-tensorrt-de-bu-shu/</url>
      
        <content type="html"><![CDATA[<p>TensorRT的部署真的够麻烦的，害怕以后换电脑忘记怎么弄了，先记下来</p><p>首先先安装好CUDA和Cudnn，时间已经隔得够长了我已经完全忘了怎么装了，我们先假设已经装好了，然后就是去NVIDIA官网下载TensorRT的压缩包</p><p>1 将TensorRT压缩包解压<br>2 将 TensorRT-X\include中头文件复制到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vX\include<br>3 将TensorRT-X\lib 中所有lib文件复制到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vX\lib\x64<br>4 将TensorRT-X\lib 中所有dll文件复制到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vX\bin</p><p>然后验证TensorRT是否安装成功</p><p>打开 <code>TensorRT-X\samples\sampleMNIST\sample_mnist.sln</code></p><p>根据解决方案重定向，右键工程-&gt;属性，修改平台工具集</p><img src="/Lillia.github.io/2023/02/18/ji-lu-xia-tensorrt-de-bu-shu/image-20230218215312136.png" class="" title="image-20230218215312136"><p>右键工程-&gt;重新生成</p><p>然后发现不行，会提示你无法打开输入文件cudnn.lib，这个文件在cuda文件夹里，得在链接器-附加库目录中添加路径C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.7\cudnn\lib\x64</p><img src="/Lillia.github.io/2023/02/18/ji-lu-xia-tensorrt-de-bu-shu/image-20230218215853750.png" class="" title="image-20230218215853750"><p>进入Anaconda虚拟环境，进入<code>TensorRT-7.0.0.11\data\mnist</code>目录，运行<code>python download_pgms.py</code>，如果TensorRT版本够高，就已经下好了</p><p>进入<code>TensorRT-7.0.0.11\bin</code>，双击<code>sample_mnist.exe</code>，如果没有报错则说配置成功。</p><p>但是一般都会报错：Could not locate zlibwapi.dll. Please make sure it is in your library path!</p><img src="/Lillia.github.io/2023/02/18/ji-lu-xia-tensorrt-de-bu-shu/image-20230218215455480.png" class="" title="image-20230218215455480"><p><a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#install-zlib-windows">Installation Guide :: NVIDIA Deep Learning cuDNN Documentation</a></p><img src="/Lillia.github.io/2023/02/18/ji-lu-xia-tensorrt-de-bu-shu/image-20230218215539669.png" class="" title="image-20230218215539669"><p><a href="http://www.winimage.com/zLibDll/zlib123dllx64.zip">http://www.winimage.com/zLibDll/zlib123dllx64.zip</a></p><p>到这条链接下载zlib压缩包，edge可能还下载不了，得去谷歌浏览器</p><p>解压以后将zlibwapi.dll移动到C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\vX\bin</p><p>再次运行就可以了</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> blog </tag>
            
            <tag> TensorRT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于YoloV5的游戏自瞄框架</title>
      <link href="/Lillia.github.io/2023/02/16/ji-yu-yolov5-de-you-xi-zi-miao-kuang-jia/"/>
      <url>/Lillia.github.io/2023/02/16/ji-yu-yolov5-de-you-xi-zi-miao-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p>本项目仅限于学习交流不可商用，不可用于非法用途（包括但不限于：用于制作游戏外挂等）。</p><p>一开始是觉得不应该讲得太详细，但实际上不管是原理还是代码，在网上都是一找一大堆了，真有心也能拿去用了，还是记录一下。</p><p>实现一个AI自瞄，基本是三步走，屏幕截图——目标检测——鼠标移动，只有目标检测这一步需要用到AI，接下来各个部分分开讲一下。</p><p>首先是屏幕截图，如果确定要用Pytorch作为框架的话，那么Python的截图方法主要是三种：</p><p>第一种是用PIL或者Pillow进行图像处理，这两个库是大部分Python图像处理类的项目都会有的库，优点是很方便，但是效率不怎么样。</p><p>第二种是用pyautogui，这个库是自动化图形界面库，除了截图以外还能够控制鼠标，但是可能是为了跨平台使用，pyautogui的运行速度也很差，在我的电脑上截一张图需要0.02s左右，额，我跑一次Yolo才0.04秒，这都占一半时间了</p><p>第三种是用win32api，这个是微软给的应用程序编程接口，可以进行截图，缺点是代码比较长，不能跨平台，但是应该也没人会用Linux，Mac打游戏吧。</p><p>除此之外还有一些其他方法，比方说OBS提供了Python的api用于构建脚本，这个效率也很高，毕竟广泛用于直播推流，但是OBS是写在C平台上的，如果是用TensorFlow会比较方便。</p><p>在GitHub上有一个快速截图的库：d3dshot，至少在我测试下来，这个速度应该是最快的，但是缺点是一旦切屏出去了，截图就会出问题，没找出问题在哪。</p><p>这样看来最适合的截图库就只剩下了win32api和d3dshot，时间上差不多，但是win32api似乎BUG更少。</p><h2 id="键盘事件监听"><a href="#键盘事件监听" class="headerlink" title="键盘事件监听"></a>键盘事件监听</h2><p>在开始之前我们需要监听键盘的动作，这一部分通过pynput实现：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">mode <span class="token operator">=</span> <span class="token boolean">False</span><span class="token keyword">def</span> <span class="token function">on_press</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> mode    <span class="token keyword">if</span> key <span class="token operator">==</span> keyboard<span class="token punctuation">.</span>Key<span class="token punctuation">.</span>f11<span class="token punctuation">:</span>        mode <span class="token operator">=</span> <span class="token keyword">not</span> mode<span class="token keyword">def</span> <span class="token function">on_release</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""松开按键时执行。"""</span>    <span class="token comment"># if key == keyboard.Key.esc:</span>    <span class="token comment">#     pass</span>    <span class="token keyword">pass</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    listener <span class="token operator">=</span> keyboard<span class="token punctuation">.</span>Listener<span class="token punctuation">(</span>        on_press<span class="token operator">=</span>on_press<span class="token punctuation">,</span>        on_release<span class="token operator">=</span>on_release<span class="token punctuation">)</span>    listener<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样就可以通过f11来进行开启或关闭，当然也可以改成别的按键，因为python貌似并没有哪个库支持鼠标侧键的读取，所以可以在鼠标驱动写一个简单的按键触发。</p><h2 id="屏幕截取"><a href="#屏幕截取" class="headerlink" title="屏幕截取"></a>屏幕截取</h2><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">window_prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    hwnd <span class="token operator">=</span> <span class="token number">0</span>  <span class="token comment"># 窗口的编号，0号表示当前活跃窗口</span>    <span class="token comment"># 根据窗口句柄获取窗口的设备上下文DC（Divice Context）</span>    hwnd_dc <span class="token operator">=</span> win32gui<span class="token punctuation">.</span>GetWindowDC<span class="token punctuation">(</span>hwnd<span class="token punctuation">)</span>    <span class="token comment"># 根据窗口的DC获取mfcDC</span>    mfc_dc <span class="token operator">=</span> win32ui<span class="token punctuation">.</span>CreateDCFromHandle<span class="token punctuation">(</span>hwnd_dc<span class="token punctuation">)</span>    <span class="token comment"># mfcDC创建可兼容的DC</span>    save_dc <span class="token operator">=</span> mfc_dc<span class="token punctuation">.</span>CreateCompatibleDC<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 创建bigmap准备保存图片</span>    save_bit_map <span class="token operator">=</span> win32ui<span class="token punctuation">.</span>CreateBitmap<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 获取监控器信息</span>    width <span class="token operator">=</span> <span class="token number">640</span>    height <span class="token operator">=</span> <span class="token number">360</span>    <span class="token comment"># 为bitmap开辟空间</span>    save_bit_map<span class="token punctuation">.</span>CreateCompatibleBitmap<span class="token punctuation">(</span>mfc_dc<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>    <span class="token keyword">return</span> save_bit_map<span class="token punctuation">,</span> save_dc<span class="token punctuation">,</span> mfc_dc<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token keyword">def</span> <span class="token function">window_capture</span><span class="token punctuation">(</span>save_bit_map<span class="token punctuation">,</span> save_dc<span class="token punctuation">,</span> mfc_dc<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 高度saveDC，将截图保存到saveBitmap中</span>    save_dc<span class="token punctuation">.</span>SelectObject<span class="token punctuation">(</span>save_bit_map<span class="token punctuation">)</span>    <span class="token comment"># 截取从左上角（0，0）长宽为（w，h）的图片</span>    <span class="token comment"># saveDC.BitBlt((0, 0), (w, h), mfcDC, (0, 0), win32con.SRCCOPY)</span>    save_dc<span class="token punctuation">.</span>BitBlt<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">,</span> mfc_dc<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">640</span><span class="token punctuation">,</span> <span class="token number">360</span><span class="token punctuation">)</span><span class="token punctuation">,</span> win32con<span class="token punctuation">.</span>SRCCOPY<span class="token punctuation">)</span>    signed_ints_array <span class="token operator">=</span> save_bit_map<span class="token punctuation">.</span>GetBitmapBits<span class="token punctuation">(</span><span class="token boolean">True</span><span class="token punctuation">)</span>    img <span class="token operator">=</span> np<span class="token punctuation">.</span>frombuffer<span class="token punctuation">(</span>signed_ints_array<span class="token punctuation">,</span> dtype<span class="token operator">=</span><span class="token string">'uint8'</span><span class="token punctuation">)</span>    img<span class="token punctuation">.</span>shape <span class="token operator">=</span> <span class="token punctuation">(</span>height<span class="token punctuation">,</span> width<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>    img0 <span class="token operator">=</span> img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">3</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> img0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序初始化阶段先运行window_prepare，之后通过键盘控制是否循环触发window_capture，捕获屏幕中央640x360的空间，进行检测，移动鼠标。（我这里的分辨率是1920x1080）</p><p>检测的部分跟之前的行人检测的demo是一致的，这里就不提了。总之是把截图丢给YoloV5，跑出结果后把坐标返回。</p><p><a href="https://diduseemyelk.github.io/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/">行人检测demo | 莉莉娅！ (diduseemyelk.github.io)</a></p><p>当然我们这里还有一个小问题，YoloV5跑完之后的结果坐标默认是按照置信度进行排序的，但很显然，如果有多个目标的时候，一般采取就近原则，谁离准心近，就瞄哪，所以还有一个小函数计算哪一组坐标离准心最近。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">closest</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> boxes<span class="token punctuation">)</span><span class="token punctuation">:</span>distance_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> label<span class="token punctuation">,</span> conf<span class="token punctuation">)</span> <span class="token keyword">in</span> boxes<span class="token punctuation">:</span>mid_x <span class="token operator">=</span> <span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        mid_y <span class="token operator">=</span> <span class="token punctuation">(</span>y1 <span class="token operator">+</span> y2<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span>        distance <span class="token operator">=</span> <span class="token punctuation">(</span>mid_x <span class="token operator">-</span> <span class="token number">960</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token punctuation">(</span>mid_y <span class="token operator">-</span> <span class="token number">540</span><span class="token punctuation">)</span><span class="token operator">**</span><span class="token number">2</span>        distance_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>distance<span class="token punctuation">)</span>value <span class="token operator">=</span> <span class="token builtin">min</span><span class="token punctuation">(</span>distance_list<span class="token punctuation">)</span>index <span class="token operator">=</span> distance_list<span class="token punctuation">.</span>index<span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token keyword">return</span> index<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="鼠标移动"><a href="#鼠标移动" class="headerlink" title="鼠标移动"></a>鼠标移动</h2><p>鼠标的移动也有很多库可以用，还是跟上面一样，pyautogui的效率很低，我很难想象只是移动一下鼠标的操作，在pyautogui上都需要0.02s，GitHub上有一个mouse的第三方库，用这个库实现的话耗时是检测不到的。</p><p>具体代码我们连着前面两部分一起讲</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">aiming</span><span class="token punctuation">(</span>save_bit_map<span class="token punctuation">,</span> save_dc<span class="token punctuation">,</span> mfc_dc<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 读取每帧图片</span>    im <span class="token operator">=</span> window_capture<span class="token punctuation">(</span>save_bit_map<span class="token punctuation">,</span> save_dc<span class="token punctuation">,</span> mfc_dc<span class="token punctuation">,</span> width<span class="token punctuation">,</span> height<span class="token punctuation">)</span>    bboxes <span class="token operator">=</span> detector<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>im<span class="token punctuation">)</span>    <span class="token comment"># 如果画面中有bbox，即detector探测到待检测对象</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        box_index <span class="token operator">=</span> detector<span class="token punctuation">.</span>closest<span class="token punctuation">(</span>bboxes<span class="token punctuation">)</span>        check_point_x <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">-</span> bboxes<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">640</span>        check_point_y <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">-</span> bboxes<span class="token punctuation">[</span>box_index<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">360</span>        move_x <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1.4</span> <span class="token operator">*</span> <span class="token punctuation">(</span>check_point_x <span class="token operator">-</span> <span class="token number">960</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        move_y <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">1.4</span> <span class="token operator">*</span> <span class="token punctuation">(</span>check_point_y <span class="token operator">-</span> <span class="token number">540</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        mouse<span class="token punctuation">.</span>move<span class="token punctuation">(</span>move_x<span class="token punctuation">,</span> move_y<span class="token punctuation">,</span> absolute<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">,</span> duration<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span>        <span class="token keyword">pass</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        <span class="token keyword">pass</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>check_point_x和check_point_y是目标检测的中心点，这个点是离准心最近的点。但是值得注意的是，并不是直接把这个参数扔进去move就可以了，因为这种第一人称射击游戏，他都不需要记录你鼠标的位置，只需要记录你鼠标相对位移，并根据你的DPI和鼠标灵敏度进行转向即可。虽然这个目标离你的准心差了可能200个像素点，但转动和平移是两件事情，如何保证你转动过后目标恰好就在你的准心上呢？这就需要用到球面理论去进行计算了。</p><p>但是在游戏里，人物模型是有大小的，对于很远的人物，Yolo识别不出来，对于很近的人物，人物HitBox又足够大，即便第一时间没有瞄到最中央，仍然能够命中，因此很大程度上，我们不需要百分百精确地计算出move_x和move_y，完全可以利用中间的线性区域作线性拟合，找到一个经验常数，能够从check_point_x和check_point_y生成出误差较小的move_x和move_y即可，不同的分辨率可能会有所不同，我这分辨率取1.4差不多是比较稳定的。最后用mouse.move函数进行鼠标操作，这里的duration是指延迟，就是执行这个鼠标操作的耗时，如果取0.1的话其实会看起来比较丝滑。</p><p>ok最后附上一段bot测试吧。</p><div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="基于YoloV5的游戏自瞄框架/Counter-strike  Global Offensive 2023.02.24 - 14.17.20.02 截取视频.mp4" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;"> </iframe></div>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> blog </tag>
            
            <tag> YOLOv5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>没解决的一个问题</title>
      <link href="/Lillia.github.io/2023/01/17/mei-jie-jue-de-yi-ge-wen-ti/"/>
      <url>/Lillia.github.io/2023/01/17/mei-jie-jue-de-yi-ge-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>这篇是准备记录之前的行人检测的demo从YoloV5移植到YoloV8遇到的一个问题</p><p>就是</p><img src="/Lillia.github.io/2023/01/17/mei-jie-jue-de-yi-ge-wen-ti/image-20230117203005726.png" class="" title="image-20230117203005726"><p>查了很多资料，一个比较合理的说法是，输入的图片是1920*1080的，而Yolo检测要求图片长宽均为64的倍数</p><p>但我觉得有点奇怪，因为我可以通过cv2.resize(im, (960, 540))修改尺寸，再扔给Yolo进行检测，此时是不会报错的，但是540同样不是64的倍数</p><p>当然一般图像在预处理过程就会经过letterbox函数进行处理，处理完都是64的倍数了，所以一般也不会报错</p><p>就是不清楚是怎么弄的，没研究出来，先记在这里</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> blog </tag>
            
            <tag> YoloV8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行人检测demo</title>
      <link href="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/"/>
      <url>/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/dyh/win10_yolov5_deepsort_counting">dyh/win10_yolov5_deepsort_counting: 在 win10 运行 yolov5 deepsort 行人 车辆 跟踪 检测 计数 (github.com)</a></p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>首先先假设我们已经安装好了Anaconda，</p><p>然后再假设我们安装好了CUDA11.7，</p><p>最好再假设我们安装好了Pycharm，</p><p>首先我们先配置一下python3.9的虚拟环境：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230108211509933.png" class=""><p>首先我们三步走进入condabin文件夹，Anaconda安装目录每个人可能不同。</p><p>接着输入conda create -n counting python=3.9</p><p>一路回车。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230108211815413.png" class=""><p>这样就创建完了，接下来激活虚拟环境，输入conda activate counting，输入后会在前面带有括号。</p><p>在项目文件夹中复制requirements文件到虚拟环境文件夹中，cmd进入虚拟环境文件夹。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109160138285.png" class=""><p>接着输入pip3 install -r requirements.txt，安装项目外部库。</p><p>虚拟环境下输入python -m pip install —upgrade pip升级pip，接下来去<a href="https://pytorch.org/get-started/locally/">Start Locally | PyTorch</a>找到对应的安装命令，下载对应CUDA版本的Pytorch，因为我电脑环境配置了CUDA11.7，这里就不在虚拟环境配置CUDA了，默认都装好了，这里输入pip3 install torch torchvision torchaudio —extra-index-url <a href="https://download.pytorch.org/whl/cu117">https://download.pytorch.org/whl/cu117</a> 。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109160206892.png" class=""><p>打开项目文件夹，右键，选择打开文件夹作为Pycharm项目，并且信任项目。</p><p>选择配置好的虚拟环境作为Python解释器。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153403933.png" class=""><p>尝试运行一下。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153443403.png" class=""><p>出现了一个小报错，小修改，将from  cv2 import cv2 改成import cv2即可。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153517419.png" class="" title="修改前"><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153535399.png" class="" title="修改后"><p>再试试：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153659840.png" class=""><p>又有新报错，查查资料，打开upsampling.py，小做修改。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153808535.png" class="" title="修改前"><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153839748.png" class="" title="修改后"><p>再试试：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153916484.png" class=""><p>能跑了，但是没有框框。</p><p>再看看，将detector.py里的model.half改成model.float，img.half改成img.float。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153952413.png" class="" title="修改前"><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109154046732.png" class="" title="修改后"><p>再试试：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109154119832.png" class=""><p>有框框了。</p><p>接下来看看代码。</p><h2 id="代码阅读"><a href="#代码阅读" class="headerlink" title="代码阅读"></a>代码阅读</h2><h3 id="detector-py"><a href="#detector-py" class="headerlink" title="detector.py"></a>detector.py</h3><h4 id="init"><a href="#init" class="headerlink" title="init"></a><strong>init</strong></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 初始化属性</span>   <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>       self<span class="token punctuation">.</span>img_size <span class="token operator">=</span> <span class="token number">640</span>     <span class="token comment"># 照片尺寸缩放</span>       self<span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token number">0.3</span>    <span class="token comment"># 置信度阈值</span>       self<span class="token punctuation">.</span>stride <span class="token operator">=</span> <span class="token number">1</span>     <span class="token comment"># 卷积步长</span>       self<span class="token punctuation">.</span>weights <span class="token operator">=</span> <span class="token string">'./weights/yolov5m.pt'</span>  <span class="token comment"># 权重模型，采用yolov5官方权重</span>       self<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token string">'0'</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">'cpu'</span>   <span class="token comment"># 训练设备根据配置选择显卡或CPU</span>       self<span class="token punctuation">.</span>device <span class="token operator">=</span> select_device<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>       model <span class="token operator">=</span> attempt_load<span class="token punctuation">(</span>self<span class="token punctuation">.</span>weights<span class="token punctuation">,</span> map_location<span class="token operator">=</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>    <span class="token comment"># 导入模型权重，指定训练设备</span>       model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       model<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 模型数据类型改为float</span>       self<span class="token punctuation">.</span>m <span class="token operator">=</span> model  <span class="token comment"># 存放model方法</span>       self<span class="token punctuation">.</span>names <span class="token operator">=</span> model<span class="token punctuation">.</span>module<span class="token punctuation">.</span>names <span class="token keyword">if</span> <span class="token builtin">hasattr</span><span class="token punctuation">(</span>           model<span class="token punctuation">,</span> <span class="token string">'module'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> model<span class="token punctuation">.</span>names   <span class="token comment"># 获得识别标签</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="preprocess"><a href="#preprocess" class="headerlink" title="preprocess"></a>preprocess</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">preprocess</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 复制图像副本，浅复制</span>    img0 <span class="token operator">=</span> img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># yolov5图像预处理letterbox，等比缩放到img_size大小，不够的地方补充黑边</span>    img <span class="token operator">=</span> letterbox<span class="token punctuation">(</span>img<span class="token punctuation">,</span> new_shape<span class="token operator">=</span>self<span class="token punctuation">.</span>img_size<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 对于opencv读取的图像数据来说，储存格式为[B,G,R]，B,G,R为色域比例</span>    <span class="token comment"># img[:, :, ::-1]指：[B,G,R]翻转成[R,G,B]</span>    <span class="token comment"># 我没特别理解这步的作用，因为貌似不进行颜色信道的翻转也能跑</span>    <span class="token comment"># img[:, :, (2, 1, 0)]这样的操作同样可以实现翻转</span>    <span class="token comment"># transpose(2, 0, 1)作用是将数据shape从(h,w,3)转变为(3,h,w)，方便计算</span>    img <span class="token operator">=</span> img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># img进行处理后，作内存连续化</span>    img <span class="token operator">=</span> np<span class="token punctuation">.</span>ascontiguousarray<span class="token punctuation">(</span>img<span class="token punctuation">)</span>    <span class="token comment"># 将img的numpy数组转变为tensor，两者共享内存，指定在显卡上</span>    img <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>    img <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># opencv采用的是256级RGB，即每个像素的RGB强度都为0-255的整数，这一步是归一重整</span>    img <span class="token operator">/=</span> <span class="token number">255.0</span>    <span class="token comment"># 如果img张量的维度是3，则将其扩容，一个RGB图片总是三维的</span>    <span class="token comment"># 扩充维度的原因估计是从一张图片的处理，变成对一堆图片的处理</span>    <span class="token keyword">if</span> img<span class="token punctuation">.</span>ndimension<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>        img <span class="token operator">=</span> img<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 返回原图和预处理后的图</span>    <span class="token keyword">return</span> img0<span class="token punctuation">,</span> img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一个方法可以写点东西。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img <span class="token operator">=</span> letterbox<span class="token punctuation">(</span>img<span class="token punctuation">,</span> new_shape<span class="token operator">=</span>self<span class="token punctuation">.</span>img_size<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>letterbox函数，深度学习模型输入图片的尺寸为正方形，而数据集中的图片一般为长方形，粗暴的resize会使得图片失真，采用letterbox可以较好的解决这个问题。该方法可以保持图片的长宽比例，剩下的部分采用灰色填充。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk5MDQ2NA==,size_16,color_FFFFFF,t_70.png" class="" title="图源https://blog.csdn.net/weixin_42990464/article/details/108493781"><p>letterbox函数的返回的第一个量是图片的RGB张量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img <span class="token operator">=</span> img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一步是对图片RGB张量的处理。</p><p>一个空白的图像画布，比如2x2，可以理解成一个2x2的矩阵</p><script type="math/tex; mode=display">\left(\begin{matrix} 颜色_{11} & 颜色_{12} \\ 颜色_{21} & 颜色_{22}\end{matrix}\right)</script><p>RGB色彩就是通过红光Red，绿光Green，和蓝光Blue按照不同的亮度混合的，因此一种颜色可以通过一个RGB矢量表示：</p><script type="math/tex; mode=display">\begin{matrix}[R_{11} &G_{11}&B_{11}]\end{matrix}</script><p>我们假设有一个2*2像素的图片，通过opencv导入后，得到的img张量大概长这样（imread方法读取图片以BGR顺序返回图像数据）：</p><script type="math/tex; mode=display">\left(\begin{matrix} [B_{11} &G_{11}&R_{11}] & [B_{12} &G_{12}&R_{12}]\\ [B_{21} &G_{21}&R_{21}] & [B_{22} &G_{22}&R_{22}]\end{matrix}\right)</script><p>是一个三维张量，shape：(2,2,3) (行像素数，列像素数，3)，可以理解成是一个二维张量矩阵，但里面装的不是数，是RGB亮度矢量，因此是2+1=3维，这样做就可以得到一张图片色彩张量。</p><p>但是imshow方法要求的以RGB的顺序进行输入以重现图像。</p><p>因此先进行倒序：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>长这样：</p><script type="math/tex; mode=display">\left(\begin{matrix} [R_{11} & G_{11}& B_{11}] & [R_{12} & G_{12}& B_{12}] \\ [R_{21} & G_{21}& B_{21}] & [R_{22} & G_{22}& B_{22}]\end{matrix}\right)</script><p>这样的shape还是(2,2,3)，我们经过：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>shape变成了(3,2,2)，长这样：</p><script type="math/tex; mode=display">I_{abc}=\left(\begin{matrix}\left[\begin{matrix} R_{11} & R_{12}\\ R_{21} & R_{22}\end{matrix}\right]&\left[\begin{matrix} G_{11} & G_{12}\\ G_{21} & G_{22}\end{matrix}\right]&\left[\begin{matrix} B_{11} & B_{12}\\ B_{21} & B_{22}\end{matrix}\right]\end{matrix}\right)</script><p>可以理解成本来是一个shape=3的一维向量，但是里面放的不是数了，而是矩阵。</p><p>单独拎出来看，这是一个只有红光强度的单色图层：</p><script type="math/tex; mode=display">红色图层=\begin{matrix}\left[\begin{matrix} R_{11} & R_{12} \\ R_{21} & R_{22}\end{matrix}\right]\end{matrix}</script><p>这样整个张量就可以写成这个样子：</p><script type="math/tex; mode=display">图片张量=I_{abc}=\left(\begin{matrix}红色图层 & 绿色图层 &蓝色图层\end{matrix}\right)</script><p>后面我们通过img.unsqueeze(0)进行升维度，结果长这样：</p><script type="math/tex; mode=display">\left(\left(\begin{matrix}\left[\begin{matrix} R_{11} & R_{12}\\ R_{21} & R_{22}\end{matrix}\right]&\left[\begin{matrix} G_{11} & G_{12}\\ G_{21} & G_{22}\end{matrix}\right]&\left[\begin{matrix} B_{11} & B_{12}\\ B_{21} & B_{22}\end{matrix}\right]\end{matrix}\right)\right)</script><p>写成这样会更清晰：</p><script type="math/tex; mode=display">\left(I_{1abc}\right)=\left(图1张量\right)</script><p>再来一张照片的话就可以写成这样了：</p><script type="math/tex; mode=display">\left(\begin{matrix}I_{1abc} & I_{2abc}\end{matrix}\right)=\left(\begin{matrix}图1张量 & 图2张量\end{matrix}\right)</script><p>这样就是两帧的色彩张量。</p><pre class="line-numbers language-none"><code class="language-none">img = np.ascontiguousarray(img)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是内存连续化。</p><p>opencv将图片数据保存到img时，开辟了一组堆内存，在堆内存里保存数据，并把堆内存的操作地址给了图像数据img，这一操作地址存放在了栈内存。</p><p>但是对数据的翻转等操作改变了栈内存对堆内存的映射关系，并没有改变堆内存数据存放，因此此时内存存放看起来不连续了。</p><p>但是连续的内存运算起来更快，所以把堆内存的数据重新排放了一遍，这样就连续了。</p><h4 id="detect"><a href="#detect" class="headerlink" title="detect"></a>detect</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">detect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> im<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 获得原图和预处理后的图</span>    im0<span class="token punctuation">,</span> img <span class="token operator">=</span> self<span class="token punctuation">.</span>preprocess<span class="token punctuation">(</span>im<span class="token punctuation">)</span>    <span class="token comment"># 调用方法拿到model</span>    <span class="token comment"># 根据github，augment是推理增强</span>    <span class="token comment"># model本身是一个函数方法，self.m获得这个方法后进行运算，得到一堆预测坐标</span>    pred <span class="token operator">=</span> self<span class="token punctuation">.</span>m<span class="token punctuation">(</span>img<span class="token punctuation">,</span> augment<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    pred <span class="token operator">=</span> pred<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># NMS非极大值抑制，排除大部分预测坐标</span>    pred <span class="token operator">=</span> non_max_suppression<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> self<span class="token punctuation">.</span>threshold<span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">)</span>    <span class="token comment"># 空盒子</span>    boxes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 对pred中的所有数据</span>    <span class="token keyword">for</span> det <span class="token keyword">in</span> pred<span class="token punctuation">:</span>        <span class="token comment"># 如果pred不为空</span>        <span class="token keyword">if</span> det <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>det<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 不同尺寸图片，坐标的映射改写</span>            det<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> scale_coords<span class="token punctuation">(</span>                img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> det<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> im0<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 坐标，置信度，类别序号</span>            <span class="token keyword">for</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> conf<span class="token punctuation">,</span> cls_id <span class="token keyword">in</span> det<span class="token punctuation">:</span>                lbl <span class="token operator">=</span> self<span class="token punctuation">.</span>names<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>cls_id<span class="token punctuation">)</span><span class="token punctuation">]</span>   <span class="token comment"># 根据序号找到类别</span>                <span class="token keyword">if</span> lbl <span class="token keyword">not</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'person'</span><span class="token punctuation">,</span> <span class="token string">'bicycle'</span><span class="token punctuation">,</span> <span class="token string">'car'</span><span class="token punctuation">,</span> <span class="token string">'motorcycle'</span><span class="token punctuation">,</span> <span class="token string">'bus'</span><span class="token punctuation">,</span> <span class="token string">'truck'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>    <span class="token comment"># 判断是否是这几个类别之一</span>                <span class="token keyword">pass</span>                x1<span class="token punctuation">,</span> y1 <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                x2<span class="token punctuation">,</span> y2 <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                boxes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>                    <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> lbl<span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> boxes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里关键是scale_coords函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">det<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> scale_coords<span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> det<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> im0<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们在前面把图像进行了缩放，缩放后再拿去跑模型检测，所以得到的坐标是缩放之后的图片坐标，但是我们希望得到原图的坐标，因此进行了这个函数。</p><h3 id="tracker-py"><a href="#tracker-py" class="headerlink" title="tracker.py"></a>tracker.py</h3><h4 id="config载入"><a href="#config载入" class="headerlink" title="config载入"></a>config载入</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">cfg <span class="token operator">=</span> get_config<span class="token punctuation">(</span><span class="token punctuation">)</span>cfg<span class="token punctuation">.</span>merge_from_file<span class="token punctuation">(</span><span class="token string">"./deep_sort/configs/deep_sort.yaml"</span><span class="token punctuation">)</span>deepsort <span class="token operator">=</span> DeepSort<span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>REID_CKPT<span class="token punctuation">,</span>                    max_dist<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>MAX_DIST<span class="token punctuation">,</span> min_confidence<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>MIN_CONFIDENCE<span class="token punctuation">,</span>                    nms_max_overlap<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>NMS_MAX_OVERLAP<span class="token punctuation">,</span> max_iou_distance<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>MAX_IOU_DISTANCE<span class="token punctuation">,</span>                    max_age<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>MAX_AGE<span class="token punctuation">,</span> n_init<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>N_INIT<span class="token punctuation">,</span> nn_budget<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>NN_BUDGET<span class="token punctuation">,</span>                    use_cuda<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里引入了一个deepsort对象</p><h4 id="draw-bboxes"><a href="#draw-bboxes" class="headerlink" title="draw_bboxes"></a>draw_bboxes</h4><pre class="line-numbers language-none"><code class="language-none">def draw_bboxes(image, bboxes, line_thickness):     # 画框框    line_thickness = line_thickness or round(        0.002 * (image.shape[0] + image.shape[1]) * 0.5) + 1    # 线宽，要么指定，要么根据图像长宽像素算    list_pts = []    point_radius = 4    # 碰撞半径    for (x1, y1, x2, y2, cls_id, pos_id) in bboxes:        color = (0, 255, 0)        # 撞线的点        check_point_x = x1        check_point_y = int(y1 + ((y2 - y1) * 0.6))        c1, c2 = (x1, y1), (x2, y2)     # c1是左上角，c2是右下角        # 用长方形的对角端点画框，框住检测出来的人的位置        cv2.rectangle(image, c1, c2, color, thickness=line_thickness, lineType=cv2.LINE_AA)        # 字符粗细        font_thickness = max(line_thickness - 1, 1)        t_size = cv2.getTextSize(cls_id, 0, fontScale=line_thickness / 3, thickness=font_thickness)[0]        c2 = c1[0] + t_size[0], c1[1] - t_size[1] - 3   # 人框已经画完，现在将c2改为标签框的右上角，此时c1是标签框右下角        cv2.rectangle(image, c1, c2, color, -1, cv2.LINE_AA)  # 填满一个长方形色块，作为标签颜色背景        cv2.putText(image, '{} ID-{}'.format(cls_id, pos_id), (c1[0], c1[1] - 2), 0, line_thickness / 3,                    [225, 255, 255], thickness=font_thickness, lineType=cv2.LINE_AA)    # 在色块上写字        # 定义碰撞带        list_pts.append([check_point_x - point_radius, check_point_y - point_radius])        list_pts.append([check_point_x - point_radius, check_point_y + point_radius])        list_pts.append([check_point_x + point_radius, check_point_y + point_radius])        list_pts.append([check_point_x + point_radius, check_point_y - point_radius])                ndarray_pts = np.array(list_pts, np.int32)        # 人框上的红点        cv2.fillPoly(image, [ndarray_pts], color=(0, 0, 255))        # 清空        list_pts.clear()    return image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先看看几个opencv函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">c1<span class="token punctuation">,</span> c2 <span class="token operator">=</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span>     <span class="token comment"># c1是左上角，c2是右下角</span><span class="token comment"># 用长方形的对角端点画框，框住检测出来的人的位置</span>cv2<span class="token punctuation">.</span>rectangle<span class="token punctuation">(</span>image<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> color<span class="token punctuation">,</span> thickness<span class="token operator">=</span>line_thickness<span class="token punctuation">,</span> lineType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>LINE_AA<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>众所周知只需要两个点就能确定下一个矩形，c1和c2是模型检测出的人或物体所在的坐标，用c1和c2画框框就能把人给框起来，也就是下图的AB点，之后我们把c2坐标写在了C点，这样AC就可以画出标签框的颜色背景。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230111151655450.png" class=""><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输入参数：要显示的字符，字体编号，字符比例，粗细</span>cv2<span class="token punctuation">.</span>getTextSize<span class="token punctuation">(</span>cls_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fontScale<span class="token operator">=</span>line_thickness <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> thickness<span class="token operator">=</span>font_thickness<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment"># 返回值(width,height),bottom</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/5b6d8edc5b8a42a2847856f313d94dfd.png" class="" title="图源https://blog.csdn.net/weixin_43794311/article/details/127438799"><p>我们这里只取了(width,height)，并没有取bottom。</p><pre class="line-numbers language-none"><code class="language-none">cv2.fillPoly(image, [ndarray_pts], color=(0, 0, 255))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">,</span> image<span class="token punctuation">)</span><span class="token punctuation">:</span>    bbox_xywh <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># x，y，长，宽</span>    confs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 置信度</span>    bboxes2draw <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment"># 待返回数据组</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> lbl<span class="token punctuation">,</span> conf <span class="token keyword">in</span> bboxes<span class="token punctuation">:</span>            obj <span class="token operator">=</span> <span class="token punctuation">[</span>                <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y1 <span class="token operator">+</span> y2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                x2 <span class="token operator">-</span> x1<span class="token punctuation">,</span> y2 <span class="token operator">-</span> y1            <span class="token punctuation">]</span>   <span class="token comment"># 人框的中心坐标，以及方框长宽</span>            bbox_xywh<span class="token punctuation">.</span>append<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>            confs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        xywhs <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>bbox_xywh<span class="token punctuation">)</span>        confss <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>confs<span class="token punctuation">)</span>        <span class="token comment"># 下一步是目标跟踪，接收目标检测结果的矩形框坐标跑一遍deepsort</span>        <span class="token comment"># deepsort会根据先前的帧确定目标检测结果的标识ID：track_id，即判断当前矩形框里的人和前一帧哪个矩形框里的人相同，相同就赋同一个id</span>        outputs <span class="token operator">=</span> deepsort<span class="token punctuation">.</span>update<span class="token punctuation">(</span>xywhs<span class="token punctuation">,</span> confss<span class="token punctuation">,</span> image<span class="token punctuation">)</span>        <span class="token keyword">for</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> track_id <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">(</span>outputs<span class="token punctuation">)</span><span class="token punctuation">:</span>            center_x <span class="token operator">=</span> <span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>            center_y <span class="token operator">=</span> <span class="token punctuation">(</span>y1 <span class="token operator">+</span> y2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>            <span class="token comment"># 但是经过deepsort的坐标因为经过一些处理，所以与之前的坐标有不同，所以通过一个search_label的函数寻找其标签</span>            label <span class="token operator">=</span> search_label<span class="token punctuation">(</span>center_x<span class="token operator">=</span>center_x<span class="token punctuation">,</span> center_y<span class="token operator">=</span>center_y<span class="token punctuation">,</span> bboxes_xyxy<span class="token operator">=</span>bboxes<span class="token punctuation">,</span> max_dist_threshold<span class="token operator">=</span><span class="token number">20.0</span><span class="token punctuation">)</span>            bboxes2draw<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> label<span class="token punctuation">,</span> track_id<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">pass</span>    <span class="token keyword">pass</span>    <span class="token comment"># 最终我们这个函数返回的：人框矩形坐标，标签，track_id</span>    <span class="token keyword">return</span> bboxes2draw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里困难的是deepsort的理解，deepsort作为一个目标追踪的模块是比较方便的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>deepsort <span class="token operator">=</span> DeepSort<span class="token punctuation">(</span>args<span class="token punctuation">.</span>deepsort_checkpoint<span class="token punctuation">)</span><span class="token comment"># 实例化</span>outputs <span class="token operator">=</span> self<span class="token punctuation">.</span>deepsort<span class="token punctuation">.</span>update<span class="token punctuation">(</span>bbox_xcycwh<span class="token punctuation">,</span> cls_conf<span class="token punctuation">,</span> im<span class="token punctuation">)</span><span class="token comment">#通过接收目标检测结果进行更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先我们要经过一个目标检测模块，这里我们用的是yolov5，检测完后，会得到一堆的检测坐标，这些坐标其实就是上文说的人的矩形框对角坐标，把这堆坐标通过self.deepsort.update发给deepsort模块之后，deepsort会对这些矩形框进行序号标记，并且与下一帧进行对比。</p><p>当下一帧又发来一堆检测坐标的时候，deepsort会通过匈牙利算法判断两帧中哪两个矩形框框住的目标是同一个，然后给出框框的序号，这样我们的框框不仅跟着人走，还根据人的特征分发了序号，实现了目标追踪。</p><p>deepsort算法的具体内容另一篇写，这篇写不了那么多了。</p><h4 id="search-label"><a href="#search-label" class="headerlink" title="search_label"></a>search_label</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">search_label</span><span class="token punctuation">(</span>center_x<span class="token punctuation">,</span> center_y<span class="token punctuation">,</span> bboxes_xyxy<span class="token punctuation">,</span> max_dist_threshold<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    在 yolov5 的 bbox 中搜索中心点最接近的label    :param center_x:    :param center_y:    :param bboxes_xyxy:    :param max_dist_threshold:    :return: 字符串    """</span>    label <span class="token operator">=</span> <span class="token string">''</span>    <span class="token comment"># min_label = ''</span>    min_dist <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1.0</span>    <span class="token keyword">for</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> lbl<span class="token punctuation">,</span> conf <span class="token keyword">in</span> bboxes_xyxy<span class="token punctuation">:</span>        center_x2 <span class="token operator">=</span> <span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>        center_y2 <span class="token operator">=</span> <span class="token punctuation">(</span>y1 <span class="token operator">+</span> y2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>        <span class="token comment"># 横纵距离都小于 max_dist</span>        min_x <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>center_x2 <span class="token operator">-</span> center_x<span class="token punctuation">)</span>        min_y <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>center_y2 <span class="token operator">-</span> center_y<span class="token punctuation">)</span>        <span class="token keyword">if</span> min_x <span class="token operator">&lt;</span> max_dist_threshold <span class="token keyword">and</span> min_y <span class="token operator">&lt;</span> max_dist_threshold<span class="token punctuation">:</span>            <span class="token comment"># 距离阈值，判断是否在允许误差范围内</span>            <span class="token comment"># 取 x, y 方向上的距离平均值</span>            avg_dist <span class="token operator">=</span> <span class="token punctuation">(</span>min_x <span class="token operator">+</span> min_y<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>            <span class="token keyword">if</span> min_dist <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">:</span>                <span class="token comment"># 第一次赋值</span>                min_dist <span class="token operator">=</span> avg_dist                <span class="token comment"># 赋值label</span>                label <span class="token operator">=</span> lbl                <span class="token keyword">pass</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 若不是第一次，则距离小的优先</span>                <span class="token keyword">if</span> avg_dist <span class="token operator">&lt;</span> min_dist<span class="token punctuation">:</span>                    min_dist <span class="token operator">=</span> avg_dist                    <span class="token comment"># label</span>                    label <span class="token operator">=</span> lbl                <span class="token keyword">pass</span>            <span class="token keyword">pass</span>        <span class="token keyword">pass</span>    <span class="token keyword">return</span> label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一个函数是因为，我们在拿到deepsort返回的矩形框坐标的时候，实际上跟我们发送过去的矩形框坐标有一点出入，但只相差几个像素，所以我们完全可以根据像素距离确定框框坐标的对应关系。</p><p>很容易看懂，就是把deepsort的矩形框中心坐标发进去，然后跟yolov5检测出的所有框框中心坐标对比，看跟哪个最近，把最近那个框框的标签取下来返回就行，看得懂python就能看得懂这段。</p><h3 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment"># 背景幕布，一个1080*1920的零矩阵，二维张量</span>    mask_image_temp <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1080</span><span class="token punctuation">,</span> <span class="token number">1920</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    <span class="token comment"># 蓝色撞线带</span>    list_pts_blue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">204</span><span class="token punctuation">,</span> <span class="token number">305</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">227</span><span class="token punctuation">,</span> <span class="token number">431</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">605</span><span class="token punctuation">,</span> <span class="token number">522</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1101</span><span class="token punctuation">,</span> <span class="token number">464</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1900</span><span class="token punctuation">,</span> <span class="token number">601</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1902</span><span class="token punctuation">,</span> <span class="token number">495</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1125</span><span class="token punctuation">,</span> <span class="token number">379</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">604</span><span class="token punctuation">,</span> <span class="token number">437</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token punctuation">[</span><span class="token number">299</span><span class="token punctuation">,</span> <span class="token number">375</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">267</span><span class="token punctuation">,</span> <span class="token number">289</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    ndarray_pts_blue <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>list_pts_blue<span class="token punctuation">,</span> np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>    polygon_blue_value_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>fillPoly<span class="token punctuation">(</span>mask_image_temp<span class="token punctuation">,</span> <span class="token punctuation">[</span>ndarray_pts_blue<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 色彩通带升维度，由原来的1080*1920的矩阵，升成三维张量，1080*1920的矩阵上放的不再是数而是RGB向量</span>    polygon_blue_value_1 <span class="token operator">=</span> polygon_blue_value_1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span>    <span class="token comment"># 填充第二个多边形撞线带</span>    mask_image_temp <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1080</span><span class="token punctuation">,</span> <span class="token number">1920</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    list_pts_yellow <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">181</span><span class="token punctuation">,</span> <span class="token number">305</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">207</span><span class="token punctuation">,</span> <span class="token number">442</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">603</span><span class="token punctuation">,</span> <span class="token number">544</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1107</span><span class="token punctuation">,</span> <span class="token number">485</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1898</span><span class="token punctuation">,</span> <span class="token number">625</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1893</span><span class="token punctuation">,</span> <span class="token number">701</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1101</span><span class="token punctuation">,</span> <span class="token number">568</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                       <span class="token punctuation">[</span><span class="token number">594</span><span class="token punctuation">,</span> <span class="token number">637</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">118</span><span class="token punctuation">,</span> <span class="token number">483</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">109</span><span class="token punctuation">,</span> <span class="token number">303</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    ndarray_pts_yellow <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>list_pts_yellow<span class="token punctuation">,</span> np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>    polygon_yellow_value_2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>fillPoly<span class="token punctuation">(</span>mask_image_temp<span class="token punctuation">,</span> <span class="token punctuation">[</span>ndarray_pts_yellow<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    polygon_yellow_value_2 <span class="token operator">=</span> polygon_yellow_value_2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span>    <span class="token comment"># 撞线检测用mask，包含2个polygon，（值范围 0、1、2），供撞线计算使用</span>    <span class="token comment"># mask上，值0像素无碰撞检测，值1蓝色检测，值2黄色检测</span>    polygon_mask_blue_and_yellow <span class="token operator">=</span> polygon_blue_value_1 <span class="token operator">+</span> polygon_yellow_value_2    <span class="token comment"># 缩小尺寸，1920x1080-&gt;960x540</span>    polygon_mask_blue_and_yellow <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>polygon_mask_blue_and_yellow<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">960</span><span class="token punctuation">,</span> <span class="token number">540</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 蓝 色盘 b,g,r</span>    blue_color_plate <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 蓝 polygon图片</span>    blue_image <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>polygon_blue_value_1 <span class="token operator">*</span> blue_color_plate<span class="token punctuation">,</span> np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    <span class="token comment"># 黄 色盘</span>    yellow_color_plate <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">]</span>    <span class="token comment"># 黄 polygon图片</span>    yellow_image <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>polygon_yellow_value_2 <span class="token operator">*</span> yellow_color_plate<span class="token punctuation">,</span> np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    <span class="token comment"># 彩色图片（值范围 0-255）</span>    color_polygons_image <span class="token operator">=</span> blue_image <span class="token operator">+</span> yellow_image    <span class="token comment"># 缩小尺寸，1920x1080-&gt;960x540</span>    color_polygons_image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>color_polygons_image<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">960</span><span class="token punctuation">,</span> <span class="token number">540</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># list 与蓝色polygon重叠</span>    list_overlapping_blue_polygon <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># list 与黄色polygon重叠</span>    list_overlapping_yellow_polygon <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 进入数量</span>    down_count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 离开数量</span>    up_count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 设置字体类型</span>    font_draw_number <span class="token operator">=</span> cv2<span class="token punctuation">.</span>FONT_HERSHEY_SIMPLEX    <span class="token comment"># 设置字体位置</span>    draw_text_postion <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">960</span> <span class="token operator">*</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">540</span> <span class="token operator">*</span> <span class="token number">0.05</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 初始化 yolov5</span>    detector <span class="token operator">=</span> Detector<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 打开视频</span>    capture <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">r'video\test.mp4'</span><span class="token punctuation">)</span>    <span class="token comment"># 视频帧读取</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment"># 读取每帧图片</span>        _<span class="token punctuation">,</span> im <span class="token operator">=</span> capture<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 没读取出图片即视频结束，break循环</span>        <span class="token keyword">if</span> im <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token comment"># 缩小尺寸，1920x1080-&gt;960x540</span>        im <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>im<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">960</span><span class="token punctuation">,</span> <span class="token number">540</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 初始化空列表bboxs</span>        list_bboxs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 将缩小后的图片交给detector对象进行探测</span>        <span class="token comment"># 返回值(x1, y1, x2, y2, lbl, conf)</span>        bboxes <span class="token operator">=</span> detector<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>im<span class="token punctuation">)</span>        <span class="token comment"># 如果画面中有bbox，即detector探测到待检测对象</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 我们就把detector探测到的坐标发给tracker，把图片update到跟踪器</span>            list_bboxs <span class="token operator">=</span> tracker<span class="token punctuation">.</span>update<span class="token punctuation">(</span>bboxes<span class="token punctuation">,</span> im<span class="token punctuation">)</span>            <span class="token comment"># 画框</span>            <span class="token comment"># 画撞线检测点，(x1，y1 + ((y2 - y1) * 0.6)，并且将图片返回（当前取了0.6为偏移量，在tracker.py30行）</span>            output_image_frame <span class="token operator">=</span> tracker<span class="token punctuation">.</span>draw_bboxes<span class="token punctuation">(</span>im<span class="token punctuation">,</span> list_bboxs<span class="token punctuation">,</span> line_thickness<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>    <span class="token comment"># 空命令，类似C里的分号</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 如果画面中没有bbox，直接返回图片</span>            output_image_frame <span class="token operator">=</span> im        <span class="token keyword">pass</span>        <span class="token comment"># 输出图片</span>        output_image_frame <span class="token operator">=</span> cv2<span class="token punctuation">.</span>add<span class="token punctuation">(</span>output_image_frame<span class="token punctuation">,</span> color_polygons_image<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_bboxs<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># ----------------------判断撞线----------------------</span>            <span class="token keyword">for</span> item_bbox <span class="token keyword">in</span> list_bboxs<span class="token punctuation">:</span>                x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> label<span class="token punctuation">,</span> track_id <span class="token operator">=</span> item_bbox                <span class="token comment"># 撞线检测点，(x1，y1)，y方向偏移比例 0.0~1.0</span>                y1_offset <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>y1 <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y2 <span class="token operator">-</span> y1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment"># 撞线的点</span>                y <span class="token operator">=</span> y1_offset                x <span class="token operator">=</span> x1                <span class="token keyword">if</span> polygon_mask_blue_and_yellow<span class="token punctuation">[</span>y<span class="token punctuation">,</span> x<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment"># 如果撞蓝碰撞带，而且该检测点所属id未被记录，则记录</span>                    <span class="token keyword">if</span> track_id <span class="token keyword">not</span> <span class="token keyword">in</span> list_overlapping_blue_polygon<span class="token punctuation">:</span>                        list_overlapping_blue_polygon<span class="token punctuation">.</span>append<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span>                    <span class="token keyword">pass</span>                    <span class="token comment"># 判断 黄碰撞带 list 里是否有此 track_id</span>                    <span class="token comment"># 有此 track_id，则 认为是 外出方向</span>                    <span class="token keyword">if</span> track_id <span class="token keyword">in</span> list_overlapping_yellow_polygon<span class="token punctuation">:</span>                        <span class="token comment"># 外出+1</span>                        up_count <span class="token operator">+=</span> <span class="token number">1</span>                        <span class="token keyword">print</span><span class="token punctuation">(</span>                            <span class="token string-interpolation"><span class="token string">f'类别: </span><span class="token interpolation"><span class="token punctuation">{</span>label<span class="token punctuation">}</span></span><span class="token string"> | id: </span><span class="token interpolation"><span class="token punctuation">{</span>track_id<span class="token punctuation">}</span></span><span class="token string"> | 上行撞线 | 上行撞线总数: </span><span class="token interpolation"><span class="token punctuation">{</span>up_count<span class="token punctuation">}</span></span><span class="token string"> | 上行id列表: </span><span class="token interpolation"><span class="token punctuation">{</span>list_overlapping_yellow_polygon<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>                        <span class="token comment"># 删除 黄polygon list 中的此id</span>                        list_overlapping_yellow_polygon<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span>                        <span class="token keyword">pass</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment"># 无此 track_id，不做其他操作</span>                        <span class="token keyword">pass</span>                <span class="token keyword">elif</span> polygon_mask_blue_and_yellow<span class="token punctuation">[</span>y<span class="token punctuation">,</span> x<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>                    <span class="token comment"># 如果撞黄碰撞带，而且该检测点所属id未被记录，则记录</span>                    <span class="token keyword">if</span> track_id <span class="token keyword">not</span> <span class="token keyword">in</span> list_overlapping_yellow_polygon<span class="token punctuation">:</span>                        list_overlapping_yellow_polygon<span class="token punctuation">.</span>append<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span>                    <span class="token keyword">pass</span>                    <span class="token comment"># 判断蓝碰撞带 list 里是否有此 track_id</span>                    <span class="token comment"># 有此 track_id，则 认为是 进入方向</span>                    <span class="token keyword">if</span> track_id <span class="token keyword">in</span> list_overlapping_blue_polygon<span class="token punctuation">:</span>                        <span class="token comment"># 进入+1</span>                        down_count <span class="token operator">+=</span> <span class="token number">1</span>                        <span class="token keyword">print</span><span class="token punctuation">(</span>                            <span class="token string-interpolation"><span class="token string">f'类别: </span><span class="token interpolation"><span class="token punctuation">{</span>label<span class="token punctuation">}</span></span><span class="token string"> | id: </span><span class="token interpolation"><span class="token punctuation">{</span>track_id<span class="token punctuation">}</span></span><span class="token string"> | 下行撞线 | 下行撞线总数: </span><span class="token interpolation"><span class="token punctuation">{</span>down_count<span class="token punctuation">}</span></span><span class="token string"> | 下行id列表: </span><span class="token interpolation"><span class="token punctuation">{</span>list_overlapping_blue_polygon<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>                        <span class="token comment"># 删除 蓝polygon list 中的此id</span>                        list_overlapping_blue_polygon<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span>                        <span class="token keyword">pass</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment"># 无此 track_id，不做其他操作</span>                        <span class="token keyword">pass</span>                    <span class="token keyword">pass</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">pass</span>                <span class="token keyword">pass</span>            <span class="token keyword">pass</span>            <span class="token comment"># ----------------------清除无用id----------------------</span>            <span class="token comment"># 先把所有在碰撞带的id拼一起</span>            list_overlapping_all <span class="token operator">=</span> list_overlapping_yellow_polygon <span class="token operator">+</span> list_overlapping_blue_polygon            <span class="token comment"># 查查看这些经过碰撞带的id是不是都在这帧被yolo和deepsort检测到</span>            <span class="token keyword">for</span> id1 <span class="token keyword">in</span> list_overlapping_all<span class="token punctuation">:</span>                is_found <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token keyword">for</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> bbox_id <span class="token keyword">in</span> list_bboxs<span class="token punctuation">:</span>                    <span class="token keyword">if</span> bbox_id <span class="token operator">==</span> id1<span class="token punctuation">:</span>                        is_found <span class="token operator">=</span> <span class="token boolean">True</span>                        <span class="token keyword">break</span>                    <span class="token keyword">pass</span>                <span class="token keyword">pass</span>                <span class="token keyword">if</span> <span class="token keyword">not</span> is_found<span class="token punctuation">:</span>                    <span class="token comment"># 如果没找到，删除id</span>                    <span class="token keyword">if</span> id1 <span class="token keyword">in</span> list_overlapping_yellow_polygon<span class="token punctuation">:</span>                        list_overlapping_yellow_polygon<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>                    <span class="token keyword">pass</span>                    <span class="token keyword">if</span> id1 <span class="token keyword">in</span> list_overlapping_blue_polygon<span class="token punctuation">:</span>                        list_overlapping_blue_polygon<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>                    <span class="token keyword">pass</span>                <span class="token keyword">pass</span>            list_overlapping_all<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>        <span class="token comment"># ----------------------清除无用id结束----------------------</span>            <span class="token comment"># 清空list</span>            list_bboxs<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 如果图像中没有任何的bbox，则清空list</span>            list_overlapping_blue_polygon<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            list_overlapping_yellow_polygon<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>        <span class="token keyword">pass</span>        <span class="token comment"># 进出人数统计显示文本</span>        text_draw <span class="token operator">=</span> <span class="token string">'DOWN: '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>down_count<span class="token punctuation">)</span> <span class="token operator">+</span> \                    <span class="token string">' , UP: '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>up_count<span class="token punctuation">)</span>        <span class="token comment"># 文本放在画面上</span>        output_image_frame <span class="token operator">=</span> cv2<span class="token punctuation">.</span>putText<span class="token punctuation">(</span>img<span class="token operator">=</span>output_image_frame<span class="token punctuation">,</span> text<span class="token operator">=</span>text_draw<span class="token punctuation">,</span>                                         org<span class="token operator">=</span>draw_text_postion<span class="token punctuation">,</span>                                         fontFace<span class="token operator">=</span>font_draw_number<span class="token punctuation">,</span>                                         fontScale<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> thickness<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 播放</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'demo'</span><span class="token punctuation">,</span> output_image_frame<span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">pass</span>    <span class="token keyword">pass</span>    <span class="token comment"># 释放内存</span>    capture<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 关闭窗口</span>    cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>个人觉得已经写得挺清晰了，跑一遍程序看看：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112122148499.png" class=""><p>我们会发现这个id:32的person一共上行撞线了两次，下行撞线了一次，显然这里有碰撞带比较靠近，碰撞点抖动导致的问题，但是也不应该出现两次上行的检测。</p><p>我们重新看一下代码，判断上下行是通过蓝黄碰撞带实现的，进出的时候记录下他们碰撞带碰撞的先后顺序，先蓝后黄则下，先黄后蓝则上，如果视频里没有捣乱的人，那么每个人都只会碰撞到一次蓝带和一次黄带。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109154119832.png" class="" title="旧图新用"><p>比如有人先经过蓝带，此时我们在蓝带碰撞列表中记下他的id，再经过黄带，此时我们在黄带碰撞列表中记下他的id，此时是先蓝后黄，所以是下行，我们下行总数加1，但是他还在黄带上，所以要把蓝带碰撞列表的id删掉，否则就会重复加1，因为我们认为蓝带是不会重复碰撞的。</p><p>但是实际不是这样的，首先我们这个目标检测还不足够精准，撞点会出现小范围的抖动，其次碰撞带相隔太短，小抖动就会导致从蓝带跑到黄带。</p><p>我们有两种方法解决：</p><p>第一种是，我们重新改一下碰撞带，让他们之间距离大一点，保证撞点的小范围抖动不会出现从蓝带跑到黄带的判定。</p><p>第二种是，我们的碰撞带足够宽，即便撞点有小范围的抖动，我们仍然能够保证撞点第一个撞到的碰撞带是正确的。</p><p>我们可以定义一个新的列表记录已经检测过上下行判断的id：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">list_id_overlapping <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并把if部分小加一些内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> track_id <span class="token keyword">in</span> list_overlapping_blue_polygon <span class="token keyword">and</span> track_id <span class="token keyword">not</span> <span class="token keyword">in</span> list_id_overlapping<span class="token punctuation">:</span>    <span class="token comment"># 进入+1</span>    down_count <span class="token operator">+=</span> <span class="token number">1</span>    list_id_overlapping<span class="token punctuation">.</span>append<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> track_id <span class="token keyword">in</span> list_overlapping_yellow_polygon <span class="token keyword">and</span> track_id <span class="token keyword">not</span> <span class="token keyword">in</span> list_id_overlapping<span class="token punctuation">:</span>    <span class="token comment"># 外出+1</span>    up_count <span class="token operator">+=</span> <span class="token number">1</span>    list_id_overlapping<span class="token punctuation">.</span>append<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们再跑一遍：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112133308420.png" class=""><p>但是根据视频，44号应该是上行，我们在44号第一次被记录的时候设置一个breakpoint，把那帧图片用imwrite保存下来看看：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112134448214.png" class=""><p>至少在我看来应该是碰到黄色才对，但是程序记录他碰到蓝色了…</p><p>再看看碰撞点坐标：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112135329291.png" class=""><p>是(58,228)，放去gimp查看像素：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112135711534.png" class=""><p>圈住的点应该刚好就是(58,228)，也应该就是黄色碰撞带才对，看看附近的点值。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112142019419.png" class=""><p>（0是幕布，1是蓝色碰撞带，2是黄色碰撞带）突然多了几行边界的1，可能是定义的时候出了问题，也可能是opencv转换的时候出了问题，先看看未转换前的色值：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112142521106.png" class=""><p>确实是因为opencv的转换导致的，我推测这里应该是转换的时候把部分边界作了均值处理，我们把2改成3看看会不会有所变化.</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112143232011.png" class=""><p>这应该是作了些均值处理，我们把它取成10，估计均值处理就不会出现1了，代码已经讲得比较清楚了，这部分的修改就不重新放上去了。</p><p>现在结果应该就对了：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112150209019.png" class=""><p>yolo模型和deepsort算法分另外两篇发，项目工程架构到这里写完了。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> blog </tag>
            
            <tag> YOLOv5 </tag>
            
            <tag> DeepSORT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机多功能钟</title>
      <link href="/Lillia.github.io/2022/02/11/51-dan-pian-ji-duo-gong-neng-zhong/"/>
      <url>/Lillia.github.io/2022/02/11/51-dan-pian-ji-duo-gong-neng-zhong/</url>
      
        <content type="html"><![CDATA[<h2 id="知乎链接"><a href="#知乎链接" class="headerlink" title="知乎链接"></a>知乎链接</h2><p><a href="https://zhuanlan.zhihu.com/p/465914774">51单片机多功能钟的功能实现记录（7） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/353607938">51单片机多功能钟的功能实现记录（6） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/353582224">51单片机多功能钟的功能实现记录（5） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/350620136">51单片机多功能钟的功能实现记录（4） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/350355949">51单片机多功能钟的功能实现记录（3） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/350321130">51单片机多功能钟的功能实现记录（2） - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/350251379">51单片机多功能钟的功能实现记录（1） - 知乎 (zhihu.com)</a></p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>我并不想把所有知乎内容都搬过来个人博客，一个是因为内容过于分散，另一个是这个作品是最开始做的，知乎也是刚开始写的，很多东西今天看起来都有点过时了，而且作为一个记录，代码上的细节知乎上有就可以了，个人的博客里不一定还需要另一篇一模一样地文章，我还是希望从另一个角度写一下这个作品。</p><p>这个作品是利用51单片机做一个多功能钟，首先它的是个钟，然后再有多功能。于是我们就先从钟这个角度入手，先实现钟的功能。</p><p>那么开发板上是有ds1302模块的，他能实现一个时钟的计时，我们还需要想想看钟要用什么屏幕对吧。</p><p>第一，数码管。用数码管的话你就要考虑我后续加功能的话，比如要显示温度湿度，怎么显示，这就很麻烦。</p><p>第二，LCD。用LCD就有一定的自由度，但你也要考虑，是用8pin的数据脚，还是用i2c接口。</p><p>当时我还是刚开始学，开发板时钟例程用LCD就是8pin数据脚不用i2c的，那自然我是在这个基础上做的，但是这个例程是不带时间调整的，所以还要加上按键的时间调整，如果可以的话还要加上蓝牙。</p><p>一个钟你还得有闹钟功能吧，你还要说是多功能，那得是还多弄几个功能，比如什么计时器之类的。</p><p>ok那要做的工作就出来了，分为三个部分：</p><p>首先是按键的使用和功能的切换，也就是按键能够拿去调时间，也能够拿去切换不同的模式，把框架主体定下来，再把功能模块往里填，大概记录在了文章（1）。</p><p>第二是功能主体的建设，包括调整时间怎么调整，怎么把调好的时间传入给ds1302，计时器怎么实现，闹钟怎么实现，也是篇幅最大的，文章（3）（4）（6）都是记录这部分的。</p><p>第三部分是外设的实现，包括LCD的驱动，和DHT11温湿度传感器的时序与使用，记录在了文章（2）。</p><p>剩下的就是程序的优化，因为一开始写的代码有点屎山，51的那点资源不够我折腾了，所以提前进行了重构，当然重构了也是依托答辩，文章（5）记录这部分。</p><p>到这里，软件部分就完成了，剩下的就是硬件PCB和作品外壳的设计了，这部分记录在了文章（7）。</p><p>这看起来到这里就完成了，但有一个问题是文章里没有怎么提及的，那就是硬件资源问题。在文章里的按键设计是把八个按键全部用上了，但这就有一个问题，我们知道按键的触发要么通过中断，要么通过循环等待响应。八个按键要中断触发就只能额外通过与门实现，在开发板上不好实现；如果是通过循环等待响应，那程序的大部分时间就都在等待按键，只能从中抽出点时间去完成温湿度，显示更新等功能，当你功能不多的时候还好，功能多起来了，时间就很长，又反过来导致大部分时间都在等待程序运行，没有检测按键，导致按键反馈不行。如果是今天再让我去做这个作品，我当然知道应该搭个实验板，接几个与门，用中断触发，但当时我是不会的，这毕竟是第一个开始做的作品，动手能力还是比较差。这个问题后来我也发现做硬件很多时候不能只盯着代码，也要注意硬件的支持。流程也不是非得先写代码，再根据代码画硬件PCB的，也是需要互相结合的。当然这些内容很多我都在做键盘的时候遇到了，那块键盘还是挺喜欢的，所以这些问题都积累了不少的经验，也算是些经历吧。</p><p>还有就是电源管理了，必须得说这种自带电源的作品设计是需要一点经验的，因为后来疫情吧，很多时候都进不了实验室干活，在家很多东西都没办法完成，所以后来的两个作品都是不自带电源了，用的USB供电。多了个电池，不管是电路设计上，还是外壳设计都挺麻烦的。后来还有一次自带电源的作品是传感器实验那门课的期末作业，是直接买的带充放电稳压的电池了，自己不设计电源电路了，当然后来作业也交上去了，资料也基本删了，就没办法展示了。其实我还挺喜欢那个作业的，里面还有个PID的控速，就是汇报的时候没讲好，老师听不懂，没给太高的分，挺可惜的。</p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 单片机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机键盘</title>
      <link href="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/"/>
      <url>/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/</url>
      
        <content type="html"><![CDATA[<p>（其实是知乎内容的搬运）</p><h2 id="知乎链接"><a href="#知乎链接" class="headerlink" title="知乎链接"></a>知乎链接</h2><p><a href="https://zhuanlan.zhihu.com/p/370688866">低端键盘diy，从入门到放弃 - 知乎 (zhihu.com)</a></p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/v2-aa8da7ea78afd039415ca85d6d3043b4_720w.jpeg" class="" title="莉莉娅！"><p>前段时间捣鼓按键的时候突发奇想，想做一块小键盘放在左手边的104布局，方便实验输数据，左手键盘敲数据，右手鼠标，从这学期开学开始谋划，做到现在基本能看了。</p><p>这块键盘在开始谋划的时候参考了很多刘威老师的博客，顺便指路一下：</p><p><a href="https://zhuanlan.zhihu.com/p/112810009">diy从pcb到焊接，到程序调试，真正意思上的diy机械键盘pcb由ad绘制 - 知乎 (zhihu.com)</a></p><p>以及另外一个大神：</p><p><a href="https://www.zhihu.com/question/265112599/answer/297843217">你有什么有单片机或开源硬件做的有意思的作品吗？ - 知乎 (zhihu.com)</a></p><h2 id="芯片选用"><a href="#芯片选用" class="headerlink" title="芯片选用"></a><strong>芯片选用</strong></h2><p>我承认这显得很奇怪，但是我确实采用了51芯片来做这件事，芯片没有办法直接配备hid协议，因此还要单独配一个usb芯片，这里选择的是ch9329，一款可以直接将串口信息转为hid信号的芯片。</p><p>CH9329 是一款串口转标准 USB HID 设备(键盘、鼠标、自定义 HID)芯片，根据不同的工作模式， 在电脑上可被识别为标准的 USB 键盘设备、USB 鼠标设备或自定义 HID 类设备。该芯片接收客户端发送过来的串口数据，并按照 HID 类设备规范，将数据先进行打包再通过 USB 口上传给计算机。通过提供的上位机软件，用户也可自行配置芯片工作模式、串口通信模式、串口通信波特率、多种超时时间、VID、PID，以及各种 USB 字符串描述符。</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108190253036.png" class="" title="CH9328/CH9329芯片作用示意图"><h2 id="设备清单"><a href="#设备清单" class="headerlink" title="设备清单"></a><strong>设备清单</strong></h2><p>STC15W4K32S2</p><p>CH9329</p><p>TTC金粉轴</p><p>CD42锂电池芯片模块</p><p>蓝牙JDY-18（废弃）</p><p>WS2812反贴灯（废弃）</p><p>二极管1N4148</p><p>AMS1117-3.3V（废弃）</p><p>卫星轴</p><p>电容</p><p>碳纤维定位板</p><h2 id="布局设计（这一段可以参考刘威老师的博客）"><a href="#布局设计（这一段可以参考刘威老师的博客）" class="headerlink" title="布局设计（这一段可以参考刘威老师的博客）"></a><strong>布局设计（这一段可以参考刘威老师的博客）</strong></h2><p>键盘的布局可以去 <a href="http://link.zhihu.com/?target=http%3A//www.keyboard-layout-editor.com/">http://www.keyboard-layout-editor.com/</a> 进行设计</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108194020579.png" class="" title="网站页面"><p>在preset处可以选用一些比较常见的布局，注意复制粘贴的操作，选中某个键以后会在这行后面加上你复制的键位，但如果你复制的键位不止一列，它会在最下方重开一行，如果不选中任何键的话会直接粘贴在最下方新开的一行</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108194052432.png" class="" title="键盘布局设置"><p>properties处可以设定键位的名称和长宽</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108194215830.png" class="" title="键盘布局Raw Data"><p>在rawdata处得到我们需要的数据，全选后复制，进入下一个网站<a href="http://builder.swillkb.com/">Plate &amp; Case Builder - swillkb</a></p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108194437555.png" class="" title="Plate&amp;Case Builder界面"><p>在plate layout处粘贴上我们刚才复制的数据，switch type可以选择按键的类型，如果要对照着来画pcb的话，如果采用跟樱桃轴适配的一类轴体建议采用第三个（也就是我选中的这个），他跟键轴的封装是对应的，当然，在后续找厂家定制定位板的时候，前三个都是可以的。</p><p>stabilizer type指的是卫星轴/平衡杆的类型，具体可以点一下看看，比较通用的是cherry+costar{_s1:}。</p><p>edge pading指边缘补充，不打开的时候键轴离边缘距离比较短，如果需要打开的话可以适当的增大键轴离边缘距离。</p><p>plate corners 是圆角处理，根据需要选择。</p><p>custom polygons为自定义多边形，这个就得发挥你的想象力了。</p><p>kerf不知道是啥，大家可以试几个参数看看效果。</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108194517998.png" class="" title="kerf为10的情况"><p>key unit size是键轴的大小，一般不用改，除非你的轴也是定制的，而且跟公模不一样。</p><p>line size 和line color 就不说了，意义不是特别大，也比较好理解。</p><p>这里有一个叫做case type的内容，如果选择none的话，就只生成定位板的dxf，如果选择sandwich的话则生成一套的dxf，包括表面层，底层，定位板，和边框。</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108195039325.png" class="" title="关于键盘的固定可以参考这个图"><p>poker选项就有点类似直接把板子叠起来，放到一个小盒子里固定。</p><p>在pcb布线排元件的时候，我们需要把Switch Layer的dxf下载下来，打开ad，左上角file-&gt;import-&gt;dxf/dwg</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108195427130.png" class="" title="注意需要把比例调成mm，默认是mil，其他参数不是特别重要"><p>到这里前期准备就已经结束了。</p><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a><strong>程序设计</strong></h2><p>键盘的客制化目前比较主流的还是用Arduino刷qmk固件，操作比较简单，具体的刷qmk操作可以参考下面这个链接：</p><p><a href="https://zhuanlan.zhihu.com/p/79114621">低端客制化，一份简单的键盘制作记录 - 知乎 (zhihu.com)</a></p><p>另外一类的就是用stm32来实现矩阵键盘和用stm-cube实现hid协议的配置，像文章开头的两篇文章。</p><p>（但是我只会用51啊）</p><p>所以虽然很麻烦，外设还需要搭配上usb芯片，但我还是只有这种实现手段了。</p><p>矩阵扫描有三种方法，行列反置，行/列扫描，状态机，我们采取的还是列扫描（行扫描和列扫描要根据你二极管的方向决定），具体实现的代码这里就先不摆出来了。</p><p>根据矩阵扫描的结果，得到一份符合ch9329通信协议的串口数据，发送给ch9329芯片，配置好ch9329和stc芯片的波特率，就能得到hid信号。</p><p>并不需要处理长按或者短触这种操作，只需要把键盘扫描的结果发送过去即可，可以新增一个数组保存上一次的键盘数据，新的一组键盘扫描数据如果跟上次的数据一样，可以不发送新的这份数据（但我这里并没写这一部分，并不是特别重要，哪怕数据重复发送，系统也是可以处理的）。举个例子，如果我什么都没按，那键盘扫描的结果会是八个0，这八个0的数据包通过ch9329不断地发送给电脑，电脑也能够理解你是一直什么都没按；如果你只按下了a，那键盘的扫描结果会是0 0 0x10 0 0 0 0 0，这一组数据包通过ch9329不断地发送给电脑，电脑也是能够理解你是一直按着a的，并不影响实际操作。当然我们采取的是ch9329的协议传输模式，需要有数据包的包头和求和验证。具体的协议要求可以看ch9329的文档：</p><p><a href="https://max.book118.com/html/2019/0511/8130105015002023.shtm">CH9329芯片串口通信协议.PDF (book118.com)</a></p><p>这里需要讲一下这个求和验证码，键盘码协议里事实上只要把数据帧头的两个hex码当作0x01，求和就是它这里的结果了。</p><p>了解了这两个以后，剩下就是很简单的流程了：芯片扫描-&gt;得到键盘按键结果-&gt;加工成数据包串口发送给ch9329-&gt;ch9329发送usb-hid信号给电脑。只需要注意波特率就好了。</p><h2 id="蓝牙（弃用）"><a href="#蓝牙（弃用）" class="headerlink" title="蓝牙（弃用）"></a><strong>蓝牙（弃用）</strong></h2><p>蓝牙功能有两种方法实现，第一种是用具备hid协议的蓝牙模块，第二种则是再写一块蓝牙适配器，通过蓝牙传输串口数据，串口数据再通过ch9329进行hid协议信号发送。但这里由于我当时偷懒，锂电池芯片并没有画电路，而是直接把一块锂电池芯片模块焊接在pcb上（这里甚至画封装的时候画反了，又画了一块新的转接板），而这块锂电池芯片模块有一点不适合，如果这个模块进入休眠的时候，必须按一下模块自带的一个按钮才能使用锂电池的供电，并不是特别的方便，而且蓝牙放在了pcb板的边缘，为了后续方便做外壳，就把蓝牙模块给阉割了。蓝牙模块阉割以后，ams1117稳压芯片就没有什么意义了，因为已经没有第二个需要3.3v电压的器件了。</p><p>ch9329因为有协议传输模式，能够更好的避免因为数据丢包导致的各种操作问题，建议不要使用ch9328而去选用ch9329的协议传输模式，一般具备hid协议的蓝牙都是串口透传，方便但有时会出现些丢包导致的操作问题。</p><h2 id="ws2812b贴片灯（弃用）"><a href="#ws2812b贴片灯（弃用）" class="headerlink" title="ws2812b贴片灯（弃用）"></a><strong>ws2812b贴片灯（弃用）</strong></h2><p>这一部分弃用的主要原因是因为反贴的封装并没有画好。。。焊接起来并不方便，当初因为担心51系列芯片没办法同时处理串口数据发送和PWM控制，所以灯位留给了另一款块芯片控制。这一段程序参考的是论坛里的一份源码，链接如下：</p><p><a href="http://www.51hei.com/bbs/dpj-180742-1.html">基于51单片机的WS2812B全彩灯程序，亲测可用 - 单片机DIY制作 (51hei.com)</a></p><h2 id="全键无冲"><a href="#全键无冲" class="headerlink" title="全键无冲"></a><strong>全键无冲</strong></h2><p>标准的键盘hid协议一次只能传输6个普通键位，所以一般键盘都是6键无冲，但如果你会配置自定义hid协议，也是可以实现全键无冲的（二极管防鬼键只是在物理层面上实现了这种可能，实现全键无冲还是需要协议支持的），但自定义hid协议有可能导致在一些比较古老的主板上兼容性不好。hid协议的自定义可以参考一本教程叫《圈圈教你玩USB》。这里图方便我并不去配置这个内容了，当然，如果采用stm32的话可以直接用stm-cube搭建hid协议。</p><h2 id="原理图和PCB"><a href="#原理图和PCB" class="headerlink" title="原理图和PCB"></a><strong>原理图和PCB</strong></h2><p>这里看一下就可以了，事实上这个pcb的布局非常糟糕，当时做键盘的时候啥也不会，以为元件放正面会影响手感，把元件全放在了背面，导致整个pcb非常臃肿，连钉位都没加。</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200205946.png" class=""><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200340492.png" class=""><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200355419.png" class=""><p>usb接口直接选了usb母头，甚至没有选择micro-usb母口，这个设计直接被我师姐嘲讽。</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200433576.png" class=""><h2 id="外壳设计"><a href="#外壳设计" class="headerlink" title="外壳设计"></a><strong>外壳设计</strong></h2><p>刚才提到整块pcb是没有留钉位的（只留了smt贴片需要的四个1.1mm的定位孔）因此只能选用一个比较古老的家具结构——榫卯。如果要采用榫卯的话就拿钻头和锯子磨榫眼就是必须的操作了。</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200742736.png" class=""><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200805338.png" class=""><p>这里的结构比较简单，其实就是边缘托起整块pcb，定位板和键轴，定位板和pcb间距大概是3.7mm，做成一种卡扣的形式。但需要注意pcb和定位板之间需要给卫星轴的铁支架留点位置，托住pcb的部分需要留给背面边缘的元件一点空间，具体实践起来并不难，实在有设计不周到的地方就拿锯子和电钻磨掉好了，反正做榫卯就要做这种磨合保证它卡稳。</p><p>因为选择了usb母口，太厚了，所以底板加厚到了5mm，因此整个外壳高度去到了17.8mm。剩下的事情就用3d打印好了，这里用的是abs光固化。（这里建议不要去tb，直接找厂家加工）</p><p>定位板则是直接选择了碳纤维板，把第一步里得到的switch layer（其实就是定位板）拿去给厂家加工。</p><h2 id="键帽"><a href="#键帽" class="headerlink" title="键帽"></a><strong>键帽</strong></h2><p>整套键盘应该说就是为了这套键帽服务的，也是去找tb定制的五面热升华</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200855046.png" class=""><p>无非就是在photoshop上，把第一步键盘布局的jpg加载的第一个图层，把想要的图放在第二个图层，在第一个图层选中好要抓取的位置以后切到第二个图层，就能把键位的图都抠下来了。（但我师姐还是指出这个搭配并不好看）</p><p>其实本来希望的效果是图片中央的部分直接贴在键帽上方，剩下的四边延伸一下贴在四个面，但自己并不会用Illustrator，老板也是第一次做这种形式的，所以最后可能效果并没有那么理想，但也还能接受。</p><p>键帽就是圣经诵读了。《我永远喜欢朱迪》《为莉莉娅献上心脏》。</p><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200931737.png" class=""><img src="/Lillia.github.io/2021/05/09/51-dan-pian-ji-jian-pan/image-20230108200957619.png" class=""><p>GitHub链接：<a href="https://github.com/DidUSeeMyElk/51keyboard">DidUSeeMyElk/51keyboard: stc15单片机做的一个键盘 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> 单片机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 键盘 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
