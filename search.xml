<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>行人检测demo</title>
      <link href="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/"/>
      <url>/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/dyh/win10_yolov5_deepsort_counting">dyh/win10_yolov5_deepsort_counting: 在 win10 运行 yolov5 deepsort 行人 车辆 跟踪 检测 计数 (github.com)</a></p><h2 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h2><p>首先先假设我们已经安装好了Anaconda，</p><p>然后再假设我们安装好了CUDA11.7，</p><p>最好再假设我们安装好了Pycharm，</p><p>首先我们先配置一下python3.9的虚拟环境：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230108211509933.png" class=""><p>首先我们三步走进入condabin文件夹，Anaconda安装目录每个人可能不同。</p><p>接着输入conda create -n counting python=3.9</p><p>一路回车。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230108211815413.png" class=""><p>这样就创建完了，接下来激活虚拟环境，输入conda activate counting，输入后会在前面带有括号。</p><p>在项目文件夹中复制requirements文件到虚拟环境文件夹中，cmd进入虚拟环境文件夹。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109160138285.png" class=""><p>接着输入pip3 install -r requirements.txt，安装项目外部库。</p><p>虚拟环境下输入python -m pip install –upgrade pip升级pip，接下来去<a href="https://pytorch.org/get-started/locally/">Start Locally | PyTorch</a>找到对应的安装命令，下载对应CUDA版本的Pytorch，因为我电脑环境配置了CUDA11.7，这里就不在虚拟环境配置CUDA了，默认都装好了，这里输入pip3 install torch torchvision torchaudio –extra-index-url <a href="https://download.pytorch.org/whl/cu117">https://download.pytorch.org/whl/cu117</a> 。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109160206892.png" class=""><p>打开项目文件夹，右键，选择打开文件夹作为Pycharm项目，并且信任项目。</p><p>选择配置好的虚拟环境作为Python解释器。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153403933.png" class=""><p>尝试运行一下。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153443403.png" class=""><p>出现了一个小报错，小修改，将from  cv2 import cv2 改成import cv2即可。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153517419.png" class="" title="修改前"><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153535399.png" class="" title="修改后"><p>再试试：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153659840.png" class=""><p>又有新报错，查查资料，打开upsampling.py，小做修改。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153808535.png" class="" title="修改前"><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153839748.png" class="" title="修改后"><p>再试试：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153916484.png" class=""><p>能跑了，但是没有框框。</p><p>再看看，将detector.py里的model.half改成model.float，img.half改成img.float。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109153952413.png" class="" title="修改前"><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109154046732.png" class="" title="修改后"><p>再试试：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109154119832.png" class=""><p>有框框了。</p><p>接下来看看代码。</p><h2 id="代码阅读"><a href="#代码阅读" class="headerlink" title="代码阅读"></a>代码阅读</h2><h3 id="detector-py"><a href="#detector-py" class="headerlink" title="detector.py"></a>detector.py</h3><h4 id="init"><a href="#init" class="headerlink" title="init"></a><strong>init</strong></h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 初始化属性</span>   <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>       self<span class="token punctuation">.</span>img_size <span class="token operator">=</span> <span class="token number">640</span>     <span class="token comment"># 照片尺寸缩放</span>       self<span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token number">0.3</span>    <span class="token comment"># 灰度二值化阈值</span>       self<span class="token punctuation">.</span>stride <span class="token operator">=</span> <span class="token number">1</span>     <span class="token comment"># 卷积步长</span>       self<span class="token punctuation">.</span>weights <span class="token operator">=</span> <span class="token string">'./weights/yolov5m.pt'</span>  <span class="token comment"># 权重模型，采用yolov5官方权重</span>       self<span class="token punctuation">.</span>device <span class="token operator">=</span> <span class="token string">'0'</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">'cpu'</span>   <span class="token comment"># 训练设备根据配置选择显卡或CPU</span>       self<span class="token punctuation">.</span>device <span class="token operator">=</span> select_device<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>       model <span class="token operator">=</span> attempt_load<span class="token punctuation">(</span>self<span class="token punctuation">.</span>weights<span class="token punctuation">,</span> map_location<span class="token operator">=</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>    <span class="token comment"># 导入模型权重，指定训练设备</span>       model<span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">eval</span><span class="token punctuation">(</span><span class="token punctuation">)</span>       model<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment"># 模型数据类型改为float</span>       self<span class="token punctuation">.</span>m <span class="token operator">=</span> model  <span class="token comment"># 存放model方法</span>       self<span class="token punctuation">.</span>names <span class="token operator">=</span> model<span class="token punctuation">.</span>module<span class="token punctuation">.</span>names <span class="token keyword">if</span> <span class="token builtin">hasattr</span><span class="token punctuation">(</span>           model<span class="token punctuation">,</span> <span class="token string">'module'</span><span class="token punctuation">)</span> <span class="token keyword">else</span> model<span class="token punctuation">.</span>names   <span class="token comment"># 获得识别标签</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="preprocess"><a href="#preprocess" class="headerlink" title="preprocess"></a>preprocess</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">preprocess</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> img<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 复制图像副本，浅复制</span>    img0 <span class="token operator">=</span> img<span class="token punctuation">.</span>copy<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># yolov5图像预处理letterbox，等比缩放到img_size大小，不够的地方补充黑边</span>    img <span class="token operator">=</span> letterbox<span class="token punctuation">(</span>img<span class="token punctuation">,</span> new_shape<span class="token operator">=</span>self<span class="token punctuation">.</span>img_size<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 对于opencv读取的图像数据来说，储存格式为[B,G,R]，B,G,R为色域比例</span>    <span class="token comment"># img[:, :, ::-1]指：[B,G,R]翻转成[R,G,B]</span>    <span class="token comment"># 我没特别理解这步的作用，因为貌似不进行颜色信道的翻转也能跑</span>    <span class="token comment"># img[:, :, (2, 1, 0)]这样的操作同样可以实现翻转</span>    <span class="token comment"># transpose(2, 0, 1)作用是将数据shape从(h,w,3)转变为(3,h,w)，方便计算</span>    img <span class="token operator">=</span> img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># img进行处理后，作内存连续化</span>    img <span class="token operator">=</span> np<span class="token punctuation">.</span>ascontiguousarray<span class="token punctuation">(</span>img<span class="token punctuation">)</span>    <span class="token comment"># 将img的numpy数组转变为tensor，两者共享内存，指定在显卡上</span>    img <span class="token operator">=</span> torch<span class="token punctuation">.</span>from_numpy<span class="token punctuation">(</span>img<span class="token punctuation">)</span><span class="token punctuation">.</span>to<span class="token punctuation">(</span>self<span class="token punctuation">.</span>device<span class="token punctuation">)</span>    img <span class="token operator">=</span> img<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># opencv采用的是256级RGB，即每个像素的RGB强度都为0-255的整数，这一步是归一重整</span>    img <span class="token operator">/=</span> <span class="token number">255.0</span>    <span class="token comment"># 如果img张量的维度是3，则将其扩容，一个RGB图片总是三维的</span>    <span class="token comment"># 扩充维度的原因估计是从一张图片的处理，变成对一堆图片的处理</span>    <span class="token keyword">if</span> img<span class="token punctuation">.</span>ndimension<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">:</span>        img <span class="token operator">=</span> img<span class="token punctuation">.</span>unsqueeze<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token comment"># 返回原图和预处理后的图</span>    <span class="token keyword">return</span> img0<span class="token punctuation">,</span> img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一个方法可以写点东西。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img <span class="token operator">=</span> letterbox<span class="token punctuation">(</span>img<span class="token punctuation">,</span> new_shape<span class="token operator">=</span>self<span class="token punctuation">.</span>img_size<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>letterbox函数，深度学习模型输入图片的尺寸为正方形，而数据集中的图片一般为长方形，粗暴的resize会使得图片失真，采用letterbox可以较好的解决这个问题。该方法可以保持图片的长宽比例，剩下的部分采用灰色填充。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mjk5MDQ2NA==,size_16,color_FFFFFF,t_70.png" class="" title="图源https://blog.csdn.net/weixin_42990464/article/details/108493781"><p>letterbox函数的返回的第一个量是图片的RGB张量。</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img <span class="token operator">=</span> img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这一步是对图片RGB张量的处理。</p><p>一个空白的图像画布，比如2x2，可以理解成一个2x2的矩阵<br>$$<br>\left(<br>\begin{matrix}<br> 颜色_{11} &amp; 颜色_{12}\<br> 颜色_{21} &amp; 颜色_{22}<br>\end{matrix}<br>\right)<br>$$<br>RGB色彩就是通过红光Red，绿光Green，和蓝光Blue按照不同的亮度混合的，因此一种颜色可以通过一个RGB矢量表示：<br>$$<br>\begin{matrix}[R_{11} &amp;G_{11}&amp;B_{11}]\end{matrix}<br>$$<br>我们假设有一个2*2像素的图片，通过opencv导入后，得到的img张量大概长这样（imread方法读取图片以BGR顺序返回图像数据）：<br>$$<br>\left(<br>\begin{matrix}<br> [B_{11} &amp;G_{11}&amp;R_{11}] &amp; [B_{12} &amp;G_{12}&amp;R_{12}]\<br> [B_{21} &amp;G_{21}&amp;R_{21}] &amp; [B_{22} &amp;G_{22}&amp;R_{22}]<br>\end{matrix}<br>\right)<br>$$<br>是一个三维张量，shape：(2,2,3) (行像素数，列像素数，3)，可以理解成是一个二维张量矩阵，但里面装的不是数，是RGB亮度矢量，因此是2+1=3维，这样做就可以得到一张图片色彩张量。</p><p>但是imshow方法要求的以RGB的顺序进行输入以重现图像。</p><p>因此先进行倒序：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">img<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>长这样：<br>$$<br>\left(<br>\begin{matrix}<br> [R_{11} &amp; G_{11}&amp; B_{11}] &amp; [R_{12} &amp; G_{12}&amp; B_{12}]\<br> [R_{21} &amp; G_{21}&amp; B_{21}] &amp; [R_{22} &amp; G_{22}&amp; B_{22}]<br>\end{matrix}<br>\right)<br>$$<br>这样的shape还是(2,2,3)，我们经过：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token punctuation">.</span>transpose<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>shape变成了(3,2,2)，长这样：<br>$$<br>I_{abc}=\left(<br>\begin{matrix}<br>\left[<br>\begin{matrix}<br> R_{11} &amp; R_{12}\ R_{21} &amp; R_{22}<br>\end{matrix}<br>\right]&amp;<br>\left[<br>\begin{matrix}<br> G_{11} &amp; G_{12}\ G_{21} &amp; G_{22}<br>\end{matrix}<br>\right]&amp;<br>\left[<br>\begin{matrix}<br> B_{11} &amp; B_{12}\ B_{21} &amp; B_{22}<br>\end{matrix}<br>\right]<br>\end{matrix}<br>\right)<br>$$<br>可以理解成本来是一个shape=3的一维向量，但是里面放的不是数了，而是矩阵。</p><p>单独拎出来看，这是一个只有红光强度的单色图层：<br>$$<br>红色图层=\begin{matrix}<br>\left[<br>\begin{matrix}<br> R_{11} &amp; R_{12}\ R_{21} &amp; R_{22}<br>\end{matrix}<br>\right]<br>\end{matrix}<br>$$<br>这样整个张量就可以写成这个样子：<br>$$<br>图片张量=I_{abc}=\left(<br>\begin{matrix}<br>红色图层 &amp; 绿色图层 &amp;蓝色图层<br>\end{matrix}<br>\right)<br>$$<br>后面我们通过img.unsqueeze(0)进行升维度，结果长这样：<br>$$<br>\left(<br>\left(<br>\begin{matrix}<br>\left[<br>\begin{matrix}<br> R_{11} &amp; R_{12}\ R_{21} &amp; R_{22}<br>\end{matrix}<br>\right]&amp;<br>\left[<br>\begin{matrix}<br> G_{11} &amp; G_{12}\ G_{21} &amp; G_{22}<br>\end{matrix}<br>\right]&amp;<br>\left[<br>\begin{matrix}<br> B_{11} &amp; B_{12}\ B_{21} &amp; B_{22}<br>\end{matrix}<br>\right]<br>\end{matrix}<br>\right)<br>\right)<br>$$<br>写成这样会更清晰：<br>$$<br>\left(I_{1abc}\right)=\left(图1张量\right)<br>$$<br>再来一张照片的话就可以写成这样了：<br>$$<br>\left(<br>\begin{matrix}<br>I_{1abc} &amp; I_{2abc}<br>\end{matrix}<br>\right)=<br>\left(<br>\begin{matrix}<br>图1张量 &amp; 图2张量<br>\end{matrix}<br>\right)<br>$$<br>这样就是两帧的色彩张量。</p><pre class="line-numbers language-none"><code class="language-none">img = np.ascontiguousarray(img)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这是内存连续化。</p><p>opencv将图片数据保存到img时，开辟了一组堆内存，在堆内存里保存数据，并把堆内存的操作地址给了图像数据img，这一操作地址存放在了栈内存。</p><p>但是对数据的翻转等操作改变了栈内存对堆内存的映射关系，并没有改变堆内存数据存放，因此此时内存存放看起来不连续了。</p><p>但是连续的内存运算起来更快，所以把堆内存的数据重新排放了一遍，这样就连续了。</p><h4 id="detect"><a href="#detect" class="headerlink" title="detect"></a>detect</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">detect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> im<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment"># 获得原图和预处理后的图</span>    im0<span class="token punctuation">,</span> img <span class="token operator">=</span> self<span class="token punctuation">.</span>preprocess<span class="token punctuation">(</span>im<span class="token punctuation">)</span>    <span class="token comment"># 调用方法拿到model</span>    <span class="token comment"># 根据github，augment是推理增强</span>    <span class="token comment"># model本身是一个函数方法，self.m获得这个方法后进行运算，得到一堆预测坐标</span>    pred <span class="token operator">=</span> self<span class="token punctuation">.</span>m<span class="token punctuation">(</span>img<span class="token punctuation">,</span> augment<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>    pred <span class="token operator">=</span> pred<span class="token punctuation">.</span><span class="token builtin">float</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># NMS非极大值抑制，排除大部分预测坐标</span>    pred <span class="token operator">=</span> non_max_suppression<span class="token punctuation">(</span>pred<span class="token punctuation">,</span> self<span class="token punctuation">.</span>threshold<span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">)</span>    <span class="token comment"># 空盒子</span>    boxes <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 对pred中的所有数据</span>    <span class="token keyword">for</span> det <span class="token keyword">in</span> pred<span class="token punctuation">:</span>        <span class="token comment"># 如果pred不为空</span>        <span class="token keyword">if</span> det <span class="token keyword">is</span> <span class="token keyword">not</span> <span class="token boolean">None</span> <span class="token keyword">and</span> <span class="token builtin">len</span><span class="token punctuation">(</span>det<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment"># 不同尺寸图片，坐标的映射改写</span>            det<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> scale_coords<span class="token punctuation">(</span>                img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> det<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> im0<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 坐标，置信度，类别序号</span>            <span class="token keyword">for</span> <span class="token operator">*</span>x<span class="token punctuation">,</span> conf<span class="token punctuation">,</span> cls_id <span class="token keyword">in</span> det<span class="token punctuation">:</span>                lbl <span class="token operator">=</span> self<span class="token punctuation">.</span>names<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>cls_id<span class="token punctuation">)</span><span class="token punctuation">]</span>   <span class="token comment"># 根据序号找到类别</span>                <span class="token keyword">if</span> lbl <span class="token keyword">not</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token string">'person'</span><span class="token punctuation">,</span> <span class="token string">'bicycle'</span><span class="token punctuation">,</span> <span class="token string">'car'</span><span class="token punctuation">,</span> <span class="token string">'motorcycle'</span><span class="token punctuation">,</span> <span class="token string">'bus'</span><span class="token punctuation">,</span> <span class="token string">'truck'</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                    <span class="token keyword">continue</span>    <span class="token comment"># 判断是否是这几个类别之一</span>                <span class="token keyword">pass</span>                x1<span class="token punctuation">,</span> y1 <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                x2<span class="token punctuation">,</span> y2 <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                boxes<span class="token punctuation">.</span>append<span class="token punctuation">(</span>                    <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> lbl<span class="token punctuation">,</span> conf<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> boxes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里关键是scale_coords函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">det<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">=</span> scale_coords<span class="token punctuation">(</span>img<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> det<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> im0<span class="token punctuation">.</span>shape<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">round</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>我们在前面把图像进行了缩放，缩放后再拿去跑模型检测，所以得到的坐标是缩放之后的图片坐标，但是我们希望得到原图的坐标，因此进行了这个函数。</p><h3 id="tracker-py"><a href="#tracker-py" class="headerlink" title="tracker.py"></a>tracker.py</h3><h4 id="config载入"><a href="#config载入" class="headerlink" title="config载入"></a>config载入</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python">cfg <span class="token operator">=</span> get_config<span class="token punctuation">(</span><span class="token punctuation">)</span>cfg<span class="token punctuation">.</span>merge_from_file<span class="token punctuation">(</span><span class="token string">"./deep_sort/configs/deep_sort.yaml"</span><span class="token punctuation">)</span>deepsort <span class="token operator">=</span> DeepSort<span class="token punctuation">(</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>REID_CKPT<span class="token punctuation">,</span>                    max_dist<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>MAX_DIST<span class="token punctuation">,</span> min_confidence<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>MIN_CONFIDENCE<span class="token punctuation">,</span>                    nms_max_overlap<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>NMS_MAX_OVERLAP<span class="token punctuation">,</span> max_iou_distance<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>MAX_IOU_DISTANCE<span class="token punctuation">,</span>                    max_age<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>MAX_AGE<span class="token punctuation">,</span> n_init<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>N_INIT<span class="token punctuation">,</span> nn_budget<span class="token operator">=</span>cfg<span class="token punctuation">.</span>DEEPSORT<span class="token punctuation">.</span>NN_BUDGET<span class="token punctuation">,</span>                    use_cuda<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里引入了一个deepsort对象</p><h4 id="draw-bboxes"><a href="#draw-bboxes" class="headerlink" title="draw_bboxes"></a>draw_bboxes</h4><pre class="line-numbers language-none"><code class="language-none">def draw_bboxes(image, bboxes, line_thickness):     # 画框框    line_thickness = line_thickness or round(        0.002 * (image.shape[0] + image.shape[1]) * 0.5) + 1    # 线宽，要么指定，要么根据图像长宽像素算    list_pts = []    point_radius = 4    # 碰撞半径    for (x1, y1, x2, y2, cls_id, pos_id) in bboxes:        color = (0, 255, 0)        # 撞线的点        check_point_x = x1        check_point_y = int(y1 + ((y2 - y1) * 0.6))        c1, c2 = (x1, y1), (x2, y2)     # c1是左上角，c2是右下角        # 用长方形的对角端点画框，框住检测出来的人的位置        cv2.rectangle(image, c1, c2, color, thickness=line_thickness, lineType=cv2.LINE_AA)        # 字符粗细        font_thickness = max(line_thickness - 1, 1)        t_size = cv2.getTextSize(cls_id, 0, fontScale=line_thickness / 3, thickness=font_thickness)[0]        c2 = c1[0] + t_size[0], c1[1] - t_size[1] - 3   # 人框已经画完，现在将c2改为标签框的右上角，此时c1是标签框右下角        cv2.rectangle(image, c1, c2, color, -1, cv2.LINE_AA)  # 填满一个长方形色块，作为标签颜色背景        cv2.putText(image, '{} ID-{}'.format(cls_id, pos_id), (c1[0], c1[1] - 2), 0, line_thickness / 3,                    [225, 255, 255], thickness=font_thickness, lineType=cv2.LINE_AA)    # 在色块上写字        # 定义碰撞带        list_pts.append([check_point_x - point_radius, check_point_y - point_radius])        list_pts.append([check_point_x - point_radius, check_point_y + point_radius])        list_pts.append([check_point_x + point_radius, check_point_y + point_radius])        list_pts.append([check_point_x + point_radius, check_point_y - point_radius])                ndarray_pts = np.array(list_pts, np.int32)        # 人框上的红点        cv2.fillPoly(image, [ndarray_pts], color=(0, 0, 255))        # 清空        list_pts.clear()    return image<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>首先看看几个opencv函数：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">c1<span class="token punctuation">,</span> c2 <span class="token operator">=</span> <span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>x2<span class="token punctuation">,</span> y2<span class="token punctuation">)</span>     <span class="token comment"># c1是左上角，c2是右下角</span><span class="token comment"># 用长方形的对角端点画框，框住检测出来的人的位置</span>cv2<span class="token punctuation">.</span>rectangle<span class="token punctuation">(</span>image<span class="token punctuation">,</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> color<span class="token punctuation">,</span> thickness<span class="token operator">=</span>line_thickness<span class="token punctuation">,</span> lineType<span class="token operator">=</span>cv2<span class="token punctuation">.</span>LINE_AA<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>众所周知只需要两个点就能确定下一个矩形，c1和c2是模型检测出的人或物体所在的坐标，用c1和c2画框框就能把人给框起来，也就是下图的AB点，之后我们把c2坐标写在了C点，这样AC就可以画出标签框的颜色背景。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230111151655450.png" class=""><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token comment"># 输入参数：要显示的字符，字体编号，字符比例，粗细</span>cv2<span class="token punctuation">.</span>getTextSize<span class="token punctuation">(</span>cls_id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> fontScale<span class="token operator">=</span>line_thickness <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> thickness<span class="token operator">=</span>font_thickness<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment"># 返回值(width,height),bottom</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/5b6d8edc5b8a42a2847856f313d94dfd.png" class="" title="图源https://blog.csdn.net/weixin_43794311/article/details/127438799"><p>我们这里只取了(width,height)，并没有取bottom。</p><pre class="line-numbers language-none"><code class="language-none">cv2.fillPoly(image, [ndarray_pts], color=(0, 0, 255))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="update"><a href="#update" class="headerlink" title="update"></a>update</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">update</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">,</span> image<span class="token punctuation">)</span><span class="token punctuation">:</span>    bbox_xywh <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># x，y，长，宽</span>    confs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment"># 置信度</span>    bboxes2draw <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token comment"># 待返回数据组</span>    <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> lbl<span class="token punctuation">,</span> conf <span class="token keyword">in</span> bboxes<span class="token punctuation">:</span>            obj <span class="token operator">=</span> <span class="token punctuation">[</span>                <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y1 <span class="token operator">+</span> y2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                x2 <span class="token operator">-</span> x1<span class="token punctuation">,</span> y2 <span class="token operator">-</span> y1            <span class="token punctuation">]</span>   <span class="token comment"># 人框的中心坐标，以及方框长宽</span>            bbox_xywh<span class="token punctuation">.</span>append<span class="token punctuation">(</span>obj<span class="token punctuation">)</span>            confs<span class="token punctuation">.</span>append<span class="token punctuation">(</span>conf<span class="token punctuation">)</span>        xywhs <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>bbox_xywh<span class="token punctuation">)</span>        confss <span class="token operator">=</span> torch<span class="token punctuation">.</span>Tensor<span class="token punctuation">(</span>confs<span class="token punctuation">)</span>        <span class="token comment"># 下一步是目标跟踪，接收目标检测结果的矩形框坐标跑一遍deepsort</span>        <span class="token comment"># deepsort会根据先前的帧确定目标检测结果的标识ID：track_id，即判断当前矩形框里的人和前一帧哪个矩形框里的人相同，相同就赋同一个id</span>        outputs <span class="token operator">=</span> deepsort<span class="token punctuation">.</span>update<span class="token punctuation">(</span>xywhs<span class="token punctuation">,</span> confss<span class="token punctuation">,</span> image<span class="token punctuation">)</span>        <span class="token keyword">for</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> track_id <span class="token keyword">in</span> <span class="token builtin">list</span><span class="token punctuation">(</span>outputs<span class="token punctuation">)</span><span class="token punctuation">:</span>            center_x <span class="token operator">=</span> <span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>            center_y <span class="token operator">=</span> <span class="token punctuation">(</span>y1 <span class="token operator">+</span> y2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>            <span class="token comment"># 但是经过deepsort的坐标因为经过一些处理，所以与之前的坐标有不同，所以通过一个search_label的函数寻找其标签</span>            label <span class="token operator">=</span> search_label<span class="token punctuation">(</span>center_x<span class="token operator">=</span>center_x<span class="token punctuation">,</span> center_y<span class="token operator">=</span>center_y<span class="token punctuation">,</span> bboxes_xyxy<span class="token operator">=</span>bboxes<span class="token punctuation">,</span> max_dist_threshold<span class="token operator">=</span><span class="token number">20.0</span><span class="token punctuation">)</span>            bboxes2draw<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span>x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> label<span class="token punctuation">,</span> track_id<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">pass</span>    <span class="token keyword">pass</span>    <span class="token comment"># 最终我们这个函数返回的：人框矩形坐标，标签，track_id</span>    <span class="token keyword">return</span> bboxes2draw<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里困难的是deepsort的理解，deepsort作为一个目标追踪的模块是比较方便的：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">self<span class="token punctuation">.</span>deepsort <span class="token operator">=</span> DeepSort<span class="token punctuation">(</span>args<span class="token punctuation">.</span>deepsort_checkpoint<span class="token punctuation">)</span><span class="token comment"># 实例化</span>outputs <span class="token operator">=</span> self<span class="token punctuation">.</span>deepsort<span class="token punctuation">.</span>update<span class="token punctuation">(</span>bbox_xcycwh<span class="token punctuation">,</span> cls_conf<span class="token punctuation">,</span> im<span class="token punctuation">)</span><span class="token comment">#通过接收目标检测结果进行更新</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>首先我们要经过一个目标检测模块，这里我们用的是yolov5，检测完后，会得到一堆的检测坐标，这些坐标其实就是上文说的人的矩形框对角坐标，把这堆坐标通过self.deepsort.update发给deepsort模块之后，deepsort会对这些矩形框进行序号标记，并且与下一帧进行对比。</p><p>当下一帧又发来一堆检测坐标的时候，deepsort会通过匈牙利算法判断两帧中哪两个矩形框框住的目标是同一个，然后给出框框的序号，这样我们的框框不仅跟着人走，还根据人的特征分发了序号，实现了目标追踪。</p><p>deepsort算法的具体内容另一篇写，这篇写不了那么多了。</p><h4 id="search-label"><a href="#search-label" class="headerlink" title="search_label"></a>search_label</h4><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">search_label</span><span class="token punctuation">(</span>center_x<span class="token punctuation">,</span> center_y<span class="token punctuation">,</span> bboxes_xyxy<span class="token punctuation">,</span> max_dist_threshold<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token triple-quoted-string string">"""    在 yolov5 的 bbox 中搜索中心点最接近的label    :param center_x:    :param center_y:    :param bboxes_xyxy:    :param max_dist_threshold:    :return: 字符串    """</span>    label <span class="token operator">=</span> <span class="token string">''</span>    <span class="token comment"># min_label = ''</span>    min_dist <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1.0</span>    <span class="token keyword">for</span> x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> lbl<span class="token punctuation">,</span> conf <span class="token keyword">in</span> bboxes_xyxy<span class="token punctuation">:</span>        center_x2 <span class="token operator">=</span> <span class="token punctuation">(</span>x1 <span class="token operator">+</span> x2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>        center_y2 <span class="token operator">=</span> <span class="token punctuation">(</span>y1 <span class="token operator">+</span> y2<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>        <span class="token comment"># 横纵距离都小于 max_dist</span>        min_x <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>center_x2 <span class="token operator">-</span> center_x<span class="token punctuation">)</span>        min_y <span class="token operator">=</span> <span class="token builtin">abs</span><span class="token punctuation">(</span>center_y2 <span class="token operator">-</span> center_y<span class="token punctuation">)</span>        <span class="token keyword">if</span> min_x <span class="token operator">&lt;</span> max_dist_threshold <span class="token keyword">and</span> min_y <span class="token operator">&lt;</span> max_dist_threshold<span class="token punctuation">:</span>            <span class="token comment"># 距离阈值，判断是否在允许误差范围内</span>            <span class="token comment"># 取 x, y 方向上的距离平均值</span>            avg_dist <span class="token operator">=</span> <span class="token punctuation">(</span>min_x <span class="token operator">+</span> min_y<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.5</span>            <span class="token keyword">if</span> min_dist <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">:</span>                <span class="token comment"># 第一次赋值</span>                min_dist <span class="token operator">=</span> avg_dist                <span class="token comment"># 赋值label</span>                label <span class="token operator">=</span> lbl                <span class="token keyword">pass</span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                <span class="token comment"># 若不是第一次，则距离小的优先</span>                <span class="token keyword">if</span> avg_dist <span class="token operator">&lt;</span> min_dist<span class="token punctuation">:</span>                    min_dist <span class="token operator">=</span> avg_dist                    <span class="token comment"># label</span>                    label <span class="token operator">=</span> lbl                <span class="token keyword">pass</span>            <span class="token keyword">pass</span>        <span class="token keyword">pass</span>    <span class="token keyword">return</span> label<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这一个函数是因为，我们在拿到deepsort返回的矩形框坐标的时候，实际上跟我们发送过去的矩形框坐标有一点出入，但只相差几个像素，所以我们完全可以根据像素距离确定框框坐标的对应关系。</p><p>很容易看懂，就是把deepsort的矩形框中心坐标发进去，然后跟yolov5检测出的所有框框中心坐标对比，看跟哪个最近，把最近那个框框的标签取下来返回就行，看得懂python就能看得懂这段。</p><h3 id="main-py"><a href="#main-py" class="headerlink" title="main.py"></a>main.py</h3><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    <span class="token comment"># 背景幕布，一个1080*1920的零矩阵，二维张量</span>    mask_image_temp <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1080</span><span class="token punctuation">,</span> <span class="token number">1920</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    <span class="token comment"># 蓝色撞线带</span>    list_pts_blue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">204</span><span class="token punctuation">,</span> <span class="token number">305</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">227</span><span class="token punctuation">,</span> <span class="token number">431</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">605</span><span class="token punctuation">,</span> <span class="token number">522</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1101</span><span class="token punctuation">,</span> <span class="token number">464</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1900</span><span class="token punctuation">,</span> <span class="token number">601</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1902</span><span class="token punctuation">,</span> <span class="token number">495</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1125</span><span class="token punctuation">,</span> <span class="token number">379</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">604</span><span class="token punctuation">,</span> <span class="token number">437</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token punctuation">[</span><span class="token number">299</span><span class="token punctuation">,</span> <span class="token number">375</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">267</span><span class="token punctuation">,</span> <span class="token number">289</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    ndarray_pts_blue <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>list_pts_blue<span class="token punctuation">,</span> np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>    polygon_blue_value_1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>fillPoly<span class="token punctuation">(</span>mask_image_temp<span class="token punctuation">,</span> <span class="token punctuation">[</span>ndarray_pts_blue<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>    <span class="token comment"># 色彩通带升维度，由原来的1080*1920的矩阵，升成三维张量，1080*1920的矩阵上放的不再是数而是RGB向量</span>    polygon_blue_value_1 <span class="token operator">=</span> polygon_blue_value_1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span>    <span class="token comment"># 填充第二个多边形撞线带</span>    mask_image_temp <span class="token operator">=</span> np<span class="token punctuation">.</span>zeros<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1080</span><span class="token punctuation">,</span> <span class="token number">1920</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dtype<span class="token operator">=</span>np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    list_pts_yellow <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">181</span><span class="token punctuation">,</span> <span class="token number">305</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">207</span><span class="token punctuation">,</span> <span class="token number">442</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">603</span><span class="token punctuation">,</span> <span class="token number">544</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1107</span><span class="token punctuation">,</span> <span class="token number">485</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1898</span><span class="token punctuation">,</span> <span class="token number">625</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1893</span><span class="token punctuation">,</span> <span class="token number">701</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1101</span><span class="token punctuation">,</span> <span class="token number">568</span><span class="token punctuation">]</span><span class="token punctuation">,</span>                       <span class="token punctuation">[</span><span class="token number">594</span><span class="token punctuation">,</span> <span class="token number">637</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">118</span><span class="token punctuation">,</span> <span class="token number">483</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">109</span><span class="token punctuation">,</span> <span class="token number">303</span><span class="token punctuation">]</span><span class="token punctuation">]</span>    ndarray_pts_yellow <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>list_pts_yellow<span class="token punctuation">,</span> np<span class="token punctuation">.</span>int32<span class="token punctuation">)</span>    polygon_yellow_value_2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>fillPoly<span class="token punctuation">(</span>mask_image_temp<span class="token punctuation">,</span> <span class="token punctuation">[</span>ndarray_pts_yellow<span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>    polygon_yellow_value_2 <span class="token operator">=</span> polygon_yellow_value_2<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span> <span class="token punctuation">:</span><span class="token punctuation">,</span> np<span class="token punctuation">.</span>newaxis<span class="token punctuation">]</span>    <span class="token comment"># 撞线检测用mask，包含2个polygon，（值范围 0、1、2），供撞线计算使用</span>    <span class="token comment"># mask上，值0像素无碰撞检测，值1蓝色检测，值2黄色检测</span>    polygon_mask_blue_and_yellow <span class="token operator">=</span> polygon_blue_value_1 <span class="token operator">+</span> polygon_yellow_value_2    <span class="token comment"># 缩小尺寸，1920x1080-&gt;960x540</span>    polygon_mask_blue_and_yellow <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>polygon_mask_blue_and_yellow<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">960</span><span class="token punctuation">,</span> <span class="token number">540</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 蓝 色盘 b,g,r</span>    blue_color_plate <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>    <span class="token comment"># 蓝 polygon图片</span>    blue_image <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>polygon_blue_value_1 <span class="token operator">*</span> blue_color_plate<span class="token punctuation">,</span> np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    <span class="token comment"># 黄 色盘</span>    yellow_color_plate <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">]</span>    <span class="token comment"># 黄 polygon图片</span>    yellow_image <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>polygon_yellow_value_2 <span class="token operator">*</span> yellow_color_plate<span class="token punctuation">,</span> np<span class="token punctuation">.</span>uint8<span class="token punctuation">)</span>    <span class="token comment"># 彩色图片（值范围 0-255）</span>    color_polygons_image <span class="token operator">=</span> blue_image <span class="token operator">+</span> yellow_image    <span class="token comment"># 缩小尺寸，1920x1080-&gt;960x540</span>    color_polygons_image <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>color_polygons_image<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">960</span><span class="token punctuation">,</span> <span class="token number">540</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># list 与蓝色polygon重叠</span>    list_overlapping_blue_polygon <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># list 与黄色polygon重叠</span>    list_overlapping_yellow_polygon <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token comment"># 进入数量</span>    down_count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 离开数量</span>    up_count <span class="token operator">=</span> <span class="token number">0</span>    <span class="token comment"># 设置字体类型</span>    font_draw_number <span class="token operator">=</span> cv2<span class="token punctuation">.</span>FONT_HERSHEY_SIMPLEX    <span class="token comment"># 设置字体位置</span>    draw_text_postion <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">960</span> <span class="token operator">*</span> <span class="token number">0.01</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">int</span><span class="token punctuation">(</span><span class="token number">540</span> <span class="token operator">*</span> <span class="token number">0.05</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 初始化 yolov5</span>    detector <span class="token operator">=</span> Detector<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 打开视频</span>    capture <span class="token operator">=</span> cv2<span class="token punctuation">.</span>VideoCapture<span class="token punctuation">(</span><span class="token string">r'video\test.mp4'</span><span class="token punctuation">)</span>    <span class="token comment"># 视频帧读取</span>    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>        <span class="token comment"># 读取每帧图片</span>        _<span class="token punctuation">,</span> im <span class="token operator">=</span> capture<span class="token punctuation">.</span>read<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment"># 没读取出图片即视频结束，break循环</span>        <span class="token keyword">if</span> im <span class="token keyword">is</span> <span class="token boolean">None</span><span class="token punctuation">:</span>            <span class="token keyword">break</span>        <span class="token comment"># 缩小尺寸，1920x1080-&gt;960x540</span>        im <span class="token operator">=</span> cv2<span class="token punctuation">.</span>resize<span class="token punctuation">(</span>im<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">960</span><span class="token punctuation">,</span> <span class="token number">540</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment"># 初始化空列表bboxs</span>        list_bboxs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment"># 将缩小后的图片交给detector对象进行探测</span>        <span class="token comment"># 返回值(x1, y1, x2, y2, lbl, conf)</span>        bboxes <span class="token operator">=</span> detector<span class="token punctuation">.</span>detect<span class="token punctuation">(</span>im<span class="token punctuation">)</span>        <span class="token comment"># 如果画面中有bbox，即detector探测到待检测对象</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>bboxes<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># 我们就把detector探测到的坐标发给tracker，把图片update到跟踪器</span>            list_bboxs <span class="token operator">=</span> tracker<span class="token punctuation">.</span>update<span class="token punctuation">(</span>bboxes<span class="token punctuation">,</span> im<span class="token punctuation">)</span>            <span class="token comment"># 画框</span>            <span class="token comment"># 画撞线检测点，(x1，y1 + ((y2 - y1) * 0.6)，并且将图片返回（当前取了0.6为偏移量，在tracker.py30行）</span>            output_image_frame <span class="token operator">=</span> tracker<span class="token punctuation">.</span>draw_bboxes<span class="token punctuation">(</span>im<span class="token punctuation">,</span> list_bboxs<span class="token punctuation">,</span> line_thickness<span class="token operator">=</span><span class="token boolean">None</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>    <span class="token comment"># 空命令，类似C里的分号</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 如果画面中没有bbox，直接返回图片</span>            output_image_frame <span class="token operator">=</span> im        <span class="token keyword">pass</span>        <span class="token comment"># 输出图片</span>        output_image_frame <span class="token operator">=</span> cv2<span class="token punctuation">.</span>add<span class="token punctuation">(</span>output_image_frame<span class="token punctuation">,</span> color_polygons_image<span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token builtin">len</span><span class="token punctuation">(</span>list_bboxs<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>            <span class="token comment"># ----------------------判断撞线----------------------</span>            <span class="token keyword">for</span> item_bbox <span class="token keyword">in</span> list_bboxs<span class="token punctuation">:</span>                x1<span class="token punctuation">,</span> y1<span class="token punctuation">,</span> x2<span class="token punctuation">,</span> y2<span class="token punctuation">,</span> label<span class="token punctuation">,</span> track_id <span class="token operator">=</span> item_bbox                <span class="token comment"># 撞线检测点，(x1，y1)，y方向偏移比例 0.0~1.0</span>                y1_offset <span class="token operator">=</span> <span class="token builtin">int</span><span class="token punctuation">(</span>y1 <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>y2 <span class="token operator">-</span> y1<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">0.6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment"># 撞线的点</span>                y <span class="token operator">=</span> y1_offset                x <span class="token operator">=</span> x1                <span class="token keyword">if</span> polygon_mask_blue_and_yellow<span class="token punctuation">[</span>y<span class="token punctuation">,</span> x<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">:</span>                    <span class="token comment"># 如果撞蓝碰撞带，而且该检测点所属id未被记录，则记录</span>                    <span class="token keyword">if</span> track_id <span class="token keyword">not</span> <span class="token keyword">in</span> list_overlapping_blue_polygon<span class="token punctuation">:</span>                        list_overlapping_blue_polygon<span class="token punctuation">.</span>append<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span>                    <span class="token keyword">pass</span>                    <span class="token comment"># 判断 黄碰撞带 list 里是否有此 track_id</span>                    <span class="token comment"># 有此 track_id，则 认为是 外出方向</span>                    <span class="token keyword">if</span> track_id <span class="token keyword">in</span> list_overlapping_yellow_polygon<span class="token punctuation">:</span>                        <span class="token comment"># 外出+1</span>                        up_count <span class="token operator">+=</span> <span class="token number">1</span>                        <span class="token keyword">print</span><span class="token punctuation">(</span>                            <span class="token string-interpolation"><span class="token string">f'类别: </span><span class="token interpolation"><span class="token punctuation">{</span>label<span class="token punctuation">}</span></span><span class="token string"> | id: </span><span class="token interpolation"><span class="token punctuation">{</span>track_id<span class="token punctuation">}</span></span><span class="token string"> | 上行撞线 | 上行撞线总数: </span><span class="token interpolation"><span class="token punctuation">{</span>up_count<span class="token punctuation">}</span></span><span class="token string"> | 上行id列表: </span><span class="token interpolation"><span class="token punctuation">{</span>list_overlapping_yellow_polygon<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>                        <span class="token comment"># 删除 黄polygon list 中的此id</span>                        list_overlapping_yellow_polygon<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span>                        <span class="token keyword">pass</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment"># 无此 track_id，不做其他操作</span>                        <span class="token keyword">pass</span>                <span class="token keyword">elif</span> polygon_mask_blue_and_yellow<span class="token punctuation">[</span>y<span class="token punctuation">,</span> x<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">:</span>                    <span class="token comment"># 如果撞黄碰撞带，而且该检测点所属id未被记录，则记录</span>                    <span class="token keyword">if</span> track_id <span class="token keyword">not</span> <span class="token keyword">in</span> list_overlapping_yellow_polygon<span class="token punctuation">:</span>                        list_overlapping_yellow_polygon<span class="token punctuation">.</span>append<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span>                    <span class="token keyword">pass</span>                    <span class="token comment"># 判断蓝碰撞带 list 里是否有此 track_id</span>                    <span class="token comment"># 有此 track_id，则 认为是 进入方向</span>                    <span class="token keyword">if</span> track_id <span class="token keyword">in</span> list_overlapping_blue_polygon<span class="token punctuation">:</span>                        <span class="token comment"># 进入+1</span>                        down_count <span class="token operator">+=</span> <span class="token number">1</span>                        <span class="token keyword">print</span><span class="token punctuation">(</span>                            <span class="token string-interpolation"><span class="token string">f'类别: </span><span class="token interpolation"><span class="token punctuation">{</span>label<span class="token punctuation">}</span></span><span class="token string"> | id: </span><span class="token interpolation"><span class="token punctuation">{</span>track_id<span class="token punctuation">}</span></span><span class="token string"> | 下行撞线 | 下行撞线总数: </span><span class="token interpolation"><span class="token punctuation">{</span>down_count<span class="token punctuation">}</span></span><span class="token string"> | 下行id列表: </span><span class="token interpolation"><span class="token punctuation">{</span>list_overlapping_blue_polygon<span class="token punctuation">}</span></span><span class="token string">'</span></span><span class="token punctuation">)</span>                        <span class="token comment"># 删除 蓝polygon list 中的此id</span>                        list_overlapping_blue_polygon<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span>                        <span class="token keyword">pass</span>                    <span class="token keyword">else</span><span class="token punctuation">:</span>                        <span class="token comment"># 无此 track_id，不做其他操作</span>                        <span class="token keyword">pass</span>                    <span class="token keyword">pass</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    <span class="token keyword">pass</span>                <span class="token keyword">pass</span>            <span class="token keyword">pass</span>            <span class="token comment"># ----------------------清除无用id----------------------</span>            <span class="token comment"># 先把所有在碰撞带的id拼一起</span>            list_overlapping_all <span class="token operator">=</span> list_overlapping_yellow_polygon <span class="token operator">+</span> list_overlapping_blue_polygon            <span class="token comment"># 查查看这些经过碰撞带的id是不是都在这帧被yolo和deepsort检测到</span>            <span class="token keyword">for</span> id1 <span class="token keyword">in</span> list_overlapping_all<span class="token punctuation">:</span>                is_found <span class="token operator">=</span> <span class="token boolean">False</span>                <span class="token keyword">for</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> _<span class="token punctuation">,</span> bbox_id <span class="token keyword">in</span> list_bboxs<span class="token punctuation">:</span>                    <span class="token keyword">if</span> bbox_id <span class="token operator">==</span> id1<span class="token punctuation">:</span>                        is_found <span class="token operator">=</span> <span class="token boolean">True</span>                        <span class="token keyword">break</span>                    <span class="token keyword">pass</span>                <span class="token keyword">pass</span>                <span class="token keyword">if</span> <span class="token keyword">not</span> is_found<span class="token punctuation">:</span>                    <span class="token comment"># 如果没找到，删除id</span>                    <span class="token keyword">if</span> id1 <span class="token keyword">in</span> list_overlapping_yellow_polygon<span class="token punctuation">:</span>                        list_overlapping_yellow_polygon<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>                    <span class="token keyword">pass</span>                    <span class="token keyword">if</span> id1 <span class="token keyword">in</span> list_overlapping_blue_polygon<span class="token punctuation">:</span>                        list_overlapping_blue_polygon<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>id1<span class="token punctuation">)</span>                    <span class="token keyword">pass</span>                <span class="token keyword">pass</span>            list_overlapping_all<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>        <span class="token comment"># ----------------------清除无用id结束----------------------</span>            <span class="token comment"># 清空list</span>            list_bboxs<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token comment"># 如果图像中没有任何的bbox，则清空list</span>            list_overlapping_blue_polygon<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            list_overlapping_yellow_polygon<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">pass</span>        <span class="token keyword">pass</span>        <span class="token comment"># 进出人数统计显示文本</span>        text_draw <span class="token operator">=</span> <span class="token string">'DOWN: '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>down_count<span class="token punctuation">)</span> <span class="token operator">+</span> \                    <span class="token string">' , UP: '</span> <span class="token operator">+</span> <span class="token builtin">str</span><span class="token punctuation">(</span>up_count<span class="token punctuation">)</span>        <span class="token comment"># 文本放在画面上</span>        output_image_frame <span class="token operator">=</span> cv2<span class="token punctuation">.</span>putText<span class="token punctuation">(</span>img<span class="token operator">=</span>output_image_frame<span class="token punctuation">,</span> text<span class="token operator">=</span>text_draw<span class="token punctuation">,</span>                                         org<span class="token operator">=</span>draw_text_postion<span class="token punctuation">,</span>                                         fontFace<span class="token operator">=</span>font_draw_number<span class="token punctuation">,</span>                                         fontScale<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> color<span class="token operator">=</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span> thickness<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token comment"># 播放</span>        cv2<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span><span class="token string">'demo'</span><span class="token punctuation">,</span> output_image_frame<span class="token punctuation">)</span>        cv2<span class="token punctuation">.</span>waitKey<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">pass</span>    <span class="token keyword">pass</span>    <span class="token comment"># 释放内存</span>    capture<span class="token punctuation">.</span>release<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 关闭窗口</span>    cv2<span class="token punctuation">.</span>destroyAllWindows<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>个人觉得已经写得挺清晰了，跑一遍程序看看：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112122148499.png" class=""><p>我们会发现这个id:32的person一共上行撞线了两次，下行撞线了一次，显然这里有碰撞带比较靠近，碰撞点抖动导致的问题，但是也不应该出现两次上行的检测。</p><p>我们重新看一下代码，判断上下行是通过蓝黄碰撞带实现的，进出的时候记录下他们碰撞带碰撞的先后顺序，先蓝后黄则下，先黄后蓝则上，如果视频里没有捣乱的人，那么每个人都只会碰撞到一次蓝带和一次黄带。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230109154119832.png" class="" title="旧图新用"><p>比如有人先经过蓝带，此时我们在蓝带碰撞列表中记下他的id，再经过黄带，此时我们在黄带碰撞列表中记下他的id，此时是先蓝后黄，所以是下行，我们下行总数加1，但是他还在黄带上，所以要把蓝带碰撞列表的id删掉，否则就会重复加1，因为我们认为蓝带是不会重复碰撞的。</p><p>但是实际不是这样的，首先我们这个目标检测还不足够精准，撞点会出现小范围的抖动，其次碰撞带相隔太短，小抖动就会导致从蓝带跑到黄带。</p><p>我们有两种方法解决：</p><p>第一种是，我们重新改一下碰撞带，让他们之间距离大一点，保证撞点的小范围抖动不会出现从蓝带跑到黄带的判定。</p><p>第二种是，我们的碰撞带足够宽，即便撞点有小范围的抖动，我们仍然能够保证撞点第一个撞到的碰撞带是正确的。</p><p>我们可以定义一个新的列表记录已经检测过上下行判断的id：</p><pre class="line-numbers language-python" data-language="python"><code class="language-python">list_id_overlapping <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>并把if部分小加一些内容</p><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> track_id <span class="token keyword">in</span> list_overlapping_blue_polygon <span class="token keyword">and</span> track_id <span class="token keyword">not</span> <span class="token keyword">in</span> list_id_overlapping<span class="token punctuation">:</span>    <span class="token comment"># 进入+1</span>    down_count <span class="token operator">+=</span> <span class="token number">1</span>    list_id_overlapping<span class="token punctuation">.</span>append<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">if</span> track_id <span class="token keyword">in</span> list_overlapping_yellow_polygon <span class="token keyword">and</span> track_id <span class="token keyword">not</span> <span class="token keyword">in</span> list_id_overlapping<span class="token punctuation">:</span>    <span class="token comment"># 外出+1</span>    up_count <span class="token operator">+=</span> <span class="token number">1</span>    list_id_overlapping<span class="token punctuation">.</span>append<span class="token punctuation">(</span>track_id<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>我们再跑一遍：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112133308420.png" class=""><p>但是根据视频，44号应该是上行，我们在44号第一次被记录的时候设置一个breakpoint，把那帧图片用imwrite保存下来看看：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112134448214.png" class=""><p>至少在我看来应该是碰到黄色才对，但是程序记录他碰到蓝色了…</p><p>再看看碰撞点坐标：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112135329291.png" class=""><p>是(58,228)，放去gimp查看像素：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112135711534.png" class=""><p>圈住的点应该刚好就是(58,228)，也应该就是黄色碰撞带才对，看看附近的点值。</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112142019419.png" class=""><p>（0是幕布，1是蓝色碰撞带，2是黄色碰撞带）突然多了几行边界的1，可能是定义的时候出了问题，也可能是opencv转换的时候出了问题，先看看未转换前的色值：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112142521106.png" class=""><p>确实是因为opencv的转换导致的，我推测这里应该是转换的时候把部分边界作了均值处理，我们把2改成3看看会不会有所变化.</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112143232011.png" class=""><p>这应该是作了些均值处理，我们把它取成10，估计均值处理就不会出现1了，代码已经讲得比较清楚了，这部分的修改就不重新放上去了。</p><p>现在结果应该就对了：</p><img src="/Lillia.github.io/2023/01/11/xing-ren-jian-ce-demo/image-20230112150209019.png" class=""><p>yolo模型和deepsort算法分另外两篇发，项目工程架构到这里写完了。</p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> DeepLearning </tag>
            
            <tag> YOLOv5 </tag>
            
            <tag> DeepSORT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>51单片机键盘</title>
      <link href="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/"/>
      <url>/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/</url>
      
        <content type="html"><![CDATA[<p>（其实是知乎内容的搬运）</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/v2-aa8da7ea78afd039415ca85d6d3043b4_720w.jpeg" class="" title="莉莉娅！"><p>前段时间捣鼓按键的时候突发奇想，想做一块小键盘放在左手边的104布局，方便实验输数据，左手键盘敲数据，右手鼠标，从这学期开学开始谋划，做到现在基本能看了。</p><p>这块键盘在开始谋划的时候参考了很多刘威老师的博客，顺便指路一下：</p><p><a href="https://zhuanlan.zhihu.com/p/112810009">diy从pcb到焊接，到程序调试，真正意思上的diy机械键盘pcb由ad绘制 - 知乎 (zhihu.com)</a></p><p>以及另外一个大神：</p><p><a href="https://www.zhihu.com/question/265112599/answer/297843217">你有什么有单片机或开源硬件做的有意思的作品吗？ - 知乎 (zhihu.com)</a></p><h2 id="芯片选用"><a href="#芯片选用" class="headerlink" title="芯片选用"></a><strong>芯片选用</strong></h2><p>我承认这显得很奇怪，但是我确实采用了51芯片来做这件事，芯片没有办法直接配备hid协议，因此还要单独配一个usb芯片，这里选择的是ch9329，一款可以直接将串口信息转为hid信号的芯片。</p><p>CH9329 是一款串口转标准 USB HID 设备(键盘、鼠标、自定义 HID)芯片，根据不同的工作模式， 在电脑上可被识别为标准的 USB 键盘设备、USB 鼠标设备或自定义 HID 类设备。该芯片接收客户端发送过来的串口数据，并按照 HID 类设备规范，将数据先进行打包再通过 USB 口上传给计算机。通过提供的上位机软件，用户也可自行配置芯片工作模式、串口通信模式、串口通信波特率、多种超时时间、VID、PID，以及各种 USB 字符串描述符。</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108190253036.png" class="" title="CH9328/CH9329芯片作用示意图"><h2 id="设备清单"><a href="#设备清单" class="headerlink" title="设备清单"></a><strong>设备清单</strong></h2><p>STC15W4K32S2</p><p>CH9329</p><p>TTC金粉轴</p><p>CD42锂电池芯片模块</p><p>蓝牙JDY-18（废弃）</p><p>WS2812反贴灯（废弃）</p><p>二极管1N4148</p><p>AMS1117-3.3V（废弃）</p><p>卫星轴</p><p>电容</p><p>碳纤维定位板</p><h2 id="布局设计（这一段可以参考刘威老师的博客）"><a href="#布局设计（这一段可以参考刘威老师的博客）" class="headerlink" title="布局设计（这一段可以参考刘威老师的博客）"></a><strong>布局设计（这一段可以参考刘威老师的博客）</strong></h2><p>键盘的布局可以去 <a href="http://link.zhihu.com/?target=http://www.keyboard-layout-editor.com/">http://www.keyboard-layout-editor.com/</a> 进行设计</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108194020579.png" class="" title="网站页面"><p>在preset处可以选用一些比较常见的布局，注意复制粘贴的操作，选中某个键以后会在这行后面加上你复制的键位，但如果你复制的键位不止一列，它会在最下方重开一行，如果不选中任何键的话会直接粘贴在最下方新开的一行</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108194052432.png" class="" title="键盘布局设置"><p>properties处可以设定键位的名称和长宽</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108194215830.png" class="" title="键盘布局Raw Data"><p>在rawdata处得到我们需要的数据，全选后复制，进入下一个网站<a href="http://builder.swillkb.com/">Plate &amp; Case Builder - swillkb</a></p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108194437555.png" class="" title="Plate&amp;Case Builder界面"><p>在plate layout处粘贴上我们刚才复制的数据，switch type可以选择按键的类型，如果要对照着来画pcb的话，如果采用跟樱桃轴适配的一类轴体建议采用第三个（也就是我选中的这个），他跟键轴的封装是对应的，当然，在后续找厂家定制定位板的时候，前三个都是可以的。</p><p>stabilizer type指的是卫星轴/平衡杆的类型，具体可以点一下看看，比较通用的是cherry+costar{_s1:}。</p><p>edge pading指边缘补充，不打开的时候键轴离边缘距离比较短，如果需要打开的话可以适当的增大键轴离边缘距离。</p><p>plate corners 是圆角处理，根据需要选择。</p><p>custom polygons为自定义多边形，这个就得发挥你的想象力了。</p><p>kerf不知道是啥，大家可以试几个参数看看效果。</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108194517998.png" class="" title="kerf为10的情况"><p>key unit size是键轴的大小，一般不用改，除非你的轴也是定制的，而且跟公模不一样。</p><p>line size 和line color 就不说了，意义不是特别大，也比较好理解。</p><p>这里有一个叫做case type的内容，如果选择none的话，就只生成定位板的dxf，如果选择sandwich的话则生成一套的dxf，包括表面层，底层，定位板，和边框。</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108195039325.png" class="" title="关于键盘的固定可以参考这个图"><p>poker选项就有点类似直接把板子叠起来，放到一个小盒子里固定。</p><p>在pcb布线排元件的时候，我们需要把Switch Layer的dxf下载下来，打开ad，左上角file-&gt;import-&gt;dxf/dwg</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108195427130.png" class="" title="注意需要把比例调成mm，默认是mil，其他参数不是特别重要"><p>到这里前期准备就已经结束了。</p><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a><strong>程序设计</strong></h2><p>键盘的客制化目前比较主流的还是用Arduino刷qmk固件，操作比较简单，具体的刷qmk操作可以参考下面这个链接：</p><p><a href="https://zhuanlan.zhihu.com/p/79114621">低端客制化，一份简单的键盘制作记录 - 知乎 (zhihu.com)</a></p><p>另外一类的就是用stm32来实现矩阵键盘和用stm-cube实现hid协议的配置，像文章开头的两篇文章。</p><p>（但是我只会用51啊）</p><p>所以虽然很麻烦，外设还需要搭配上usb芯片，但我还是只有这种实现手段了。</p><p>矩阵扫描有三种方法，行列反置，行/列扫描，状态机，我们采取的还是列扫描（行扫描和列扫描要根据你二极管的方向决定），具体实现的代码这里就先不摆出来了。</p><p>根据矩阵扫描的结果，得到一份符合ch9329通信协议的串口数据，发送给ch9329芯片，配置好ch9329和stc芯片的波特率，就能得到hid信号。</p><p>并不需要处理长按或者短触这种操作，只需要把键盘扫描的结果发送过去即可，可以新增一个数组保存上一次的键盘数据，新的一组键盘扫描数据如果跟上次的数据一样，可以不发送新的这份数据（但我这里并没写这一部分，并不是特别重要，哪怕数据重复发送，系统也是可以处理的）。举个例子，如果我什么都没按，那键盘扫描的结果会是八个0，这八个0的数据包通过ch9329不断地发送给电脑，电脑也能够理解你是一直什么都没按；如果你只按下了a，那键盘的扫描结果会是0 0 0x10 0 0 0 0 0，这一组数据包通过ch9329不断地发送给电脑，电脑也是能够理解你是一直按着a的，并不影响实际操作。当然我们采取的是ch9329的协议传输模式，需要有数据包的包头和求和验证。具体的协议要求可以看ch9329的文档：</p><p><a href="https://max.book118.com/html/2019/0511/8130105015002023.shtm">CH9329芯片串口通信协议.PDF (book118.com)</a></p><p>这里需要讲一下这个求和验证码，键盘码协议里事实上只要把数据帧头的两个hex码当作0x01，求和就是它这里的结果了。</p><p>了解了这两个以后，剩下就是很简单的流程了：芯片扫描-&gt;得到键盘按键结果-&gt;加工成数据包串口发送给ch9329-&gt;ch9329发送usb-hid信号给电脑。只需要注意波特率就好了。</p><h2 id="蓝牙（弃用）"><a href="#蓝牙（弃用）" class="headerlink" title="蓝牙（弃用）"></a><strong>蓝牙（弃用）</strong></h2><p>蓝牙功能有两种方法实现，第一种是用具备hid协议的蓝牙模块，第二种则是再写一块蓝牙适配器，通过蓝牙传输串口数据，串口数据再通过ch9329进行hid协议信号发送。但这里由于我当时偷懒，锂电池芯片并没有画电路，而是直接把一块锂电池芯片模块焊接在pcb上（这里甚至画封装的时候画反了，又画了一块新的转接板），而这块锂电池芯片模块有一点不适合，如果这个模块进入休眠的时候，必须按一下模块自带的一个按钮才能使用锂电池的供电，并不是特别的方便，而且蓝牙放在了pcb板的边缘，为了后续方便做外壳，就把蓝牙模块给阉割了。蓝牙模块阉割以后，ams1117稳压芯片就没有什么意义了，因为已经没有第二个需要3.3v电压的器件了。</p><p>ch9329因为有协议传输模式，能够更好的避免因为数据丢包导致的各种操作问题，建议不要使用ch9328而去选用ch9329的协议传输模式，一般具备hid协议的蓝牙都是串口透传，方便但有时会出现些丢包导致的操作问题。</p><h2 id="ws2812b贴片灯（弃用）"><a href="#ws2812b贴片灯（弃用）" class="headerlink" title="ws2812b贴片灯（弃用）"></a><strong>ws2812b贴片灯（弃用）</strong></h2><p>这一部分弃用的主要原因是因为反贴的封装并没有画好。。。焊接起来并不方便，当初因为担心51系列芯片没办法同时处理串口数据发送和PWM控制，所以灯位留给了另一款块芯片控制。这一段程序参考的是论坛里的一份源码，链接如下：</p><p><a href="http://www.51hei.com/bbs/dpj-180742-1.html">基于51单片机的WS2812B全彩灯程序，亲测可用 - 单片机DIY制作 (51hei.com)</a></p><h2 id="全键无冲"><a href="#全键无冲" class="headerlink" title="全键无冲"></a><strong>全键无冲</strong></h2><p>标准的键盘hid协议一次只能传输6个普通键位，所以一般键盘都是6键无冲，但如果你会配置自定义hid协议，也是可以实现全键无冲的（二极管防鬼键只是在物理层面上实现了这种可能，实现全键无冲还是需要协议支持的），但自定义hid协议有可能导致在一些比较古老的主板上兼容性不好。hid协议的自定义可以参考一本教程叫《圈圈教你玩USB》。这里图方便我并不去配置这个内容了，当然，如果采用stm32的话可以直接用stm-cube搭建hid协议。</p><h2 id="原理图和PCB"><a href="#原理图和PCB" class="headerlink" title="原理图和PCB"></a><strong>原理图和PCB</strong></h2><p>这里看一下就可以了，事实上这个pcb的布局非常糟糕，当时做键盘的时候啥也不会，以为元件放正面会影响手感，把元件全放在了背面，导致整个pcb非常臃肿，连钉位都没加。</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200205946.png" class=""><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200340492.png" class=""><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200355419.png" class=""><p>usb接口直接选了usb母头，甚至没有选择micro-usb母口，这个设计直接被我师姐嘲讽。</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200433576.png" class=""><h2 id="外壳设计"><a href="#外壳设计" class="headerlink" title="外壳设计"></a><strong>外壳设计</strong></h2><p>刚才提到整块pcb是没有留钉位的（只留了smt贴片需要的四个1.1mm的定位孔）因此只能选用一个比较古老的家具结构——榫卯。如果要采用榫卯的话就拿钻头和锯子磨榫眼就是必须的操作了。</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200742736.png" class=""><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200805338.png" class=""><p>这里的结构比较简单，其实就是边缘托起整块pcb，定位板和键轴，定位板和pcb间距大概是3.7mm，做成一种卡扣的形式。但需要注意pcb和定位板之间需要给卫星轴的铁支架留点位置，托住pcb的部分需要留给背面边缘的元件一点空间，具体实践起来并不难，实在有设计不周到的地方就拿锯子和电钻磨掉好了，反正做榫卯就要做这种磨合保证它卡稳。</p><p>因为选择了usb母口，太厚了，所以底板加厚到了5mm，因此整个外壳高度去到了17.8mm。剩下的事情就用3d打印好了，这里用的是abs光固化。（这里建议不要去tb，直接找厂家加工）</p><p>定位板则是直接选择了碳纤维板，把第一步里得到的switch layer（其实就是定位板）拿去给厂家加工。</p><h2 id="键帽"><a href="#键帽" class="headerlink" title="键帽"></a><strong>键帽</strong></h2><p>整套键盘应该说就是为了这套键帽服务的，也是去找tb定制的五面热升华</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200855046.png" class=""><p>无非就是在photoshop上，把第一步键盘布局的jpg加载的第一个图层，把想要的图放在第二个图层，在第一个图层选中好要抓取的位置以后切到第二个图层，就能把键位的图都抠下来了。（但我师姐还是指出这个搭配并不好看）</p><p>其实本来希望的效果是图片中央的部分直接贴在键帽上方，剩下的四边延伸一下贴在四个面，但自己并不会用Illustrator，老板也是第一次做这种形式的，所以最后可能效果并没有那么理想，但也还能接受。</p><p>键帽就是圣经诵读了。《我永远喜欢朱迪》《为莉莉娅献上心脏》。</p><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200931737.png" class=""><img src="/Lillia.github.io/2022/02/11/51-dan-pian-ji-jian-pan/image-20230108200957619.png" class=""><p>GitHub链接：<a href="https://github.com/DidUSeeMyElk/51keyboard">DidUSeeMyElk/51keyboard: stc15单片机做的一个键盘 (github.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> 单片机 </tag>
            
            <tag> 键盘 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
