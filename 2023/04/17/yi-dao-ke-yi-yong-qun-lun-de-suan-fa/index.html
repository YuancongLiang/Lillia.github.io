<!DOCTYPE HTML><html lang="zh-CN"><head><meta charset="utf-8"><meta name="keywords" content="一道可以用群论的算法, 莉莉娅！"><meta name="description" content="前言一道leetcode上的题目：
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。
初级算法 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台
示例 :

输入: nums "><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no"><meta name="renderer" content="webkit|ie-stand|ie-comp"><meta name="mobile-web-app-capable" content="yes"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"><meta name="referrer" content="no-referrer-when-downgrade"><title>一道可以用群论的算法 | 莉莉娅！</title><link rel="icon" type="image/png" href="/Lillia.github.io/favicon.png"><link rel="stylesheet" href="/Lillia.github.io/libs/awesome/css/all.min.css"><link rel="stylesheet" href="/Lillia.github.io/libs/materialize/materialize.min.css"><link rel="stylesheet" href="/Lillia.github.io/libs/aos/aos.css"><link rel="stylesheet" href="/Lillia.github.io/libs/animate/animate.min.css"><link rel="stylesheet" href="/Lillia.github.io/libs/lightGallery/css/lightgallery.min.css"><link rel="stylesheet" href="/Lillia.github.io/css/matery.css"><link rel="stylesheet" href="/Lillia.github.io/css/my.css"><link rel="stylesheet" href="/Lillia.github.io/css/dark.css" media="none" onload='"all"!=media&&(media="all")'><link rel="stylesheet" href="/Lillia.github.io/libs/tocbot/tocbot.css"><link rel="stylesheet" href="/Lillia.github.io/css/post.css"><link rel="stylesheet" href="/Lillia.github.io/css/reward.css"><script src="/Lillia.github.io/libs/jquery/jquery-3.6.0.min.js"></script><meta name="generator" content="Hexo 6.3.0"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/Lillia.github.io/atom.xml" title="莉莉娅！" type="application/atom+xml"></head><body><header class="navbar-fixed"><nav id="headNav" class="bg-color nav-transparent"><div id="navContainer" class="nav-wrapper container"><div class="brand-logo"><a href="/Lillia.github.io/" class="waves-effect waves-light"><img src="/Lillia.github.io/medias/logo.png" class="logo-img" alt="LOGO"> <span class="logo-span">莉莉娅！</span></a></div><a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a><ul class="right nav-menu"><li class="hide-on-med-and-down nav-item"><a href="/Lillia.github.io/" class="waves-effect waves-light"><i class="fas fa-home" style="zoom:.6"></i> <span>首页</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/Lillia.github.io/tags" class="waves-effect waves-light"><i class="fas fa-tags" style="zoom:.6"></i> <span>标签</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/Lillia.github.io/categories" class="waves-effect waves-light"><i class="fas fa-bookmark" style="zoom:.6"></i> <span>分类</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/Lillia.github.io/archives" class="waves-effect waves-light"><i class="fas fa-archive" style="zoom:.6"></i> <span>归档</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/Lillia.github.io/about" class="waves-effect waves-light"><i class="fas fa-user-circle" style="zoom:.6"></i> <span>关于</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/Lillia.github.io/contact" class="waves-effect waves-light"><i class="fas fa-comments" style="zoom:.6"></i> <span>留言板</span></a></li><li class="hide-on-med-and-down nav-item"><a href="/Lillia.github.io/friends" class="waves-effect waves-light"><i class="fas fa-address-book" style="zoom:.6"></i> <span>友情链接</span></a></li><li><a href="#searchModal" class="modal-trigger waves-effect waves-light"><i id="searchIcon" class="fas fa-search" title="搜索" style="zoom:.85"></i></a></li><li><a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式"><i id="sum-moon-icon" class="fas fa-sun" style="zoom:.85"></i></a></li></ul><div id="mobile-nav" class="side-nav sidenav"><div class="mobile-head bg-color"><img src="/Lillia.github.io/medias/logo.png" class="logo-img circle responsive-img"><div class="logo-name">莉莉娅！</div><div class="logo-desc">Never really desperate, only the lost of the soul.</div></div><ul class="menu-list mobile-menu-list"><li class="m-nav-item"><a href="/Lillia.github.io/" class="waves-effect waves-light"><i class="fa-fw fas fa-home"></i> 首页</a></li><li class="m-nav-item"><a href="/Lillia.github.io/tags" class="waves-effect waves-light"><i class="fa-fw fas fa-tags"></i> 标签</a></li><li class="m-nav-item"><a href="/Lillia.github.io/categories" class="waves-effect waves-light"><i class="fa-fw fas fa-bookmark"></i> 分类</a></li><li class="m-nav-item"><a href="/Lillia.github.io/archives" class="waves-effect waves-light"><i class="fa-fw fas fa-archive"></i> 归档</a></li><li class="m-nav-item"><a href="/Lillia.github.io/about" class="waves-effect waves-light"><i class="fa-fw fas fa-user-circle"></i> 关于</a></li><li class="m-nav-item"><a href="/Lillia.github.io/contact" class="waves-effect waves-light"><i class="fa-fw fas fa-comments"></i> 留言板</a></li><li class="m-nav-item"><a href="/Lillia.github.io/friends" class="waves-effect waves-light"><i class="fa-fw fas fa-address-book"></i> 友情链接</a></li><li><div class="divider"></div></li><li><a href="https://github.com/YuancongLiang" class="waves-effect waves-light" target="_blank"><i class="fab fa-github-square fa-fw"></i> Fork Me</a></li></ul></div></div><style>.nav-transparent .github-corner{display:none!important}.github-corner{position:absolute;z-index:10;top:0;right:0;border:0;transform:scale(1.1)}.github-corner svg{color:#0f9d58;fill:#fff;height:64px;width:64px}.github-corner:hover .octo-arm{animation:a .56s ease-in-out}.github-corner .octo-arm{animation:none}@keyframes a{0%,to{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}</style><a href="https://github.com/YuancongLiang" class="github-corner tooltipped hide-on-med-and-down" target="_blank" data-tooltip="Fork Me" data-position="left" data-delay="50"><svg viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a></nav></header><div class="bg-cover pd-header post-cover" style="background-image:url(/Lillia.github.io/medias/featureimages/19.jpg)"><div class="container" style="right:0;left:0"><div class="row"><div class="col s12 m12 l12"><div class="brand"><h1 class="description center-align post-title">一道可以用群论的算法</h1></div></div></div></div></div><main class="post-container content"><div class="row"><div id="main-content" class="col s12 m12 l9"><div id="artDetail"><div class="card"><div class="card-content article-info"><div class="row tag-cate"><div class="col s7"><div class="article-tag"><a href="/Lillia.github.io/tags/%E7%BE%A4%E8%AE%BA/"><span class="chip bg-color">群论</span></a> <a href="/Lillia.github.io/tags/%E7%AE%97%E6%B3%95/"><span class="chip bg-color">算法</span></a></div></div><div class="col s5 right-align"><div class="post-cate"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/Lillia.github.io/categories/%E7%BE%A4%E8%AE%BA/" class="post-category">群论</a></div></div></div><div class="post-info"><div class="post-date info-break-policy"><i class="far fa-calendar-minus fa-fw"></i> 发布日期:&nbsp;&nbsp; 2023-04-17</div><div class="info-break-policy"><i class="far fa-file-word fa-fw"></i> 文章字数:&nbsp;&nbsp; 3.8k</div></div></div><hr class="clearfix"><link rel="stylesheet" href="/Lillia.github.io/libs/prism/prism.min.css"><div class="card-content article-card-content"><div id="articleContent"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一道leetcode上的题目：</p><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p><p><a target="_blank" rel="noopener" href="https://leetcode.cn/leetbook/read/top-interview-questions-easy/x2skh7/">初级算法 - LeetBook - 力扣（LeetCode）全球极客挚爱的技术成长平台</a></p><p><strong>示例 :</strong></p><blockquote><p>输入: nums = $[1,2,3,4,5,6,7]$, $k = 3$<br>输出: $[5,6,7,1,2,3,4]$<br>解释:<br>向右轮转 1 步: $[7,1,2,3,4,5,6]$<br>向右轮转 2 步: $[6,7,1,2,3,4,5]$<br>向右轮转 3 步: $[5,6,7,1,2,3,4]$</p></blockquote><p>显而易见这是一种轮换，但可能是多次轮换，它不改变数组本身，只改变元素的位置。也就是说，这是一个置换。</p><p>先回忆下一个置换的写法：</p><blockquote><p>设<script type="math/tex">\varphi</script>是n元集合$M={a<em>{1},a</em>{2},…a_{n}}$上的一个双射置换，为了简单记为$M={1,2,…,n}$。令$\varphi=\left(\begin{matrix}<br>1&amp;2&amp;…&amp;n\<br>\varphi(1)&amp;\varphi(2)&amp;…&amp;\varphi(n)<br>\end{matrix}\right)$表示$M$上的一个置换，第一行表示原象，第二行表示像的集合。</p></blockquote><p>我们可以写出示例中的置换群表示：</p><script type="math/tex;mode=display">\varphi=\left(\begin{matrix}
1&2&3&4&5&6&7\\
5&6&7&1&2&3&4
\end{matrix}\right)</script><p>也就是把1号位的换成5号位的，把2号位的换成6号位的，3号位的换成7号位的，依此类推。</p><p>这个置换是直观的，也是容易理解的，我们很容易就有了第一种想法。</p><h2 id="算法尝试"><a href="#算法尝试" class="headerlink" title="算法尝试"></a>算法尝试</h2><h3 id="置换表示"><a href="#置换表示" class="headerlink" title="置换表示"></a>置换表示</h3><p>置换是非常直观的方法，但问题是，如果我直接把1号位的元素换成5号位的，那我就必须将1号位的元素放在一个临时变量里，否则直接赋值的话，1号位的元素就被覆盖了。</p><p>我们可以使用一个临时数组，先把原数组的值存放到一个临时数组中，然后再把临时数组的值重新赋给原数组，重新赋值的时候要保证每个元素都要往后移k位，如果超过数组的长度就从头开始，所以这里可以使用(i + k) % length来计算重新赋值的元素下标。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427150039954.png" title="置换表示原理"><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> temp<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">//把原数组值放到一个临时数组中，</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//然后在把临时数组的值重新放到原数组，并且往右移动k位</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        nums<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427165003533.png" title="算法评估"><h3 id="轮换表示"><a href="#轮换表示" class="headerlink" title="轮换表示"></a>轮换表示</h3><p>相信不用我说都看出来了，如果这个数组特别大的时候，这样做的内存消耗是很大的。</p><p>但是众所周知，一般的置换表示可以写成轮换表示。</p><blockquote><p>定义：一个置换$\sigma$如果把数码$i<em>{1}$变成$i</em>{2}$，$i<em>{2}$变成$i</em>{3}$，…，$i<em>{k-1}$变成$i</em>{k}$，$i<em>{k}$又变成$i</em>{1}$，而使得其余的元（假如还有的话）都不变，则称$\sigma$为一个k-轮换（循环）置换。记为：$\sigma=(i<em>{1}i</em>{2}…i<em>{k})=(i</em>{2}i<em>{3}…i</em>{k}i<em>{1})=…=(i</em>{k}i<em>{1}…i</em>{k-1})$</p><p>注：2-轮换简称为对换。恒等映射通常记为（1）</p></blockquote><p>我们把上文示例的置换表示改写成轮换：$\varphi=(1473625)$</p><p>实际上，有定理保证，对于每个置换都可以写成若干个不相连的轮换之积，因此这种写法总是可行的。</p><p>我们观察轮换元的规律，似乎是将数组视作一个环形，1号位向右移3位到达4号位，4号位向右移3位到达7号位，7号位向右移3位到达10号位，由于最后一个与第一个相连，因此8号位就是1号位，10号位就是3号位。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427162843085.png"> <img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427162911018.png" title="轮换表示原理"><p>依照这个思路，我们可以写出轮换表示的算法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> hold <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">boolean</span><span class="token punctuation">[</span><span class="token punctuation">]</span> visited <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">boolean</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">+</span> k<span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//如果访问过，再次访问的话，会出现原地打转的现象，</span>
            <span class="token comment">//不能再访问当前元素了，我们直接从他的下一个元素开始</span>
            index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> length<span class="token punctuation">;</span>
            hold <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
            i<span class="token operator">--</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">//把当前值保存在下一个位置，保存之前要把下一个位置的</span>
            <span class="token comment">//值给记录下来</span>
            visited<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
            nums<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hold<span class="token punctuation">;</span>
            hold <span class="token operator">=</span> temp<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是，如果数组长度length和轮换步长k不互质的话，将会在某一次轮换后回到原点。因此保留了一个数组visited表示这个元素有没有被访问过，如果被访问过就从他的下一个开始，防止原地打转。</p><p>此时意味着该置换群不止一个不相连轮换。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427163259739.png" title="算法评估"><h3 id="对换表示"><a href="#对换表示" class="headerlink" title="对换表示"></a>对换表示</h3><p>我们还是希望在轮换的基础上更进一步。一般的置换方法中，我们需要有一个大的临时数组，一般来说会带来很大的内存消耗。轮换方法中，数组的下标需要依赖大量的求余运算，这种运算总是更耗时的。</p><p>如果我们可以找到一个简单的方法，通过对换就能实现算法，那应该既能避免大的内存消耗，也能够节省时间。我们来看看chatGPT和leetcode给的答案。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    k <span class="token operator">%=</span> length<span class="token punctuation">;</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先反转全部的元素</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//在反转前k个元素</span>
    <span class="token function">reverse</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> k<span class="token punctuation">,</span> length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//接着反转剩余的</span>
<span class="token punctuation">}</span>
<span class="token comment">//把数组中从[start，end]之间的元素两两交换,也就是反转</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> start<span class="token punctuation">,</span> <span class="token keyword">int</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>start <span class="token operator">&lt;</span> end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>start<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>end<span class="token punctuation">]</span><span class="token punctuation">;</span>
        nums<span class="token punctuation">[</span>end<span class="token operator">--</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>leetcode和chatGPT给出的答案都是利用翻转实现的。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427170714697.png" title="翻转算法原理"><p>当然，大家都知道，反转无非就是一前一后的数组元素进行对换。也就是说反转给出的算法其实正是对换操作。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427171137854.png" title="算法评估"><h2 id="对换与轮换"><a href="#对换与轮换" class="headerlink" title="对换与轮换"></a>对换与轮换</h2><p>显而易见地，对换方法在时间上有着得天独厚的优势。但我们在这里讨论一点更数学的问题。</p><p>假如我们采用翻转的方法去实现功能，我们需要对数组元素进行对换操作。我想谈论的问题是：</p><p>1、翻转方法中，至多几次对换操作，就能够保证对所有情况都能达到预期效果。</p><p>答案：$n$次。（$n$为数组长度）</p><p>2、至少几次对换操作，才能够保证对所有情况都能达到预期效果。</p><p>答案：$n-1$次。（$n$为数组长度）</p><p>（第二问的意思是，如果你只能进行$n-2$次对换操作，那么无论你怎样优化算法，总有数组你无法达到预期效果）</p><p>第一问的答案是容易证明的。</p><blockquote><p>证明：共进行了三次翻转，第一次对数组$n$个元素进行翻转，第二次对数组前$k$个元素进行翻转，第三次对数组后$n-k$个元素进行翻转。</p><p>容易证明对i个元素的数组进行翻转需要$[\frac{i}{2}]$次对换，则总共需要$[\frac{n}{2}]+[\frac{k}{2}]+[\frac{n-k}{2}]$次对换</p><p>注意到$k+(n-k)=n$，因此，$k,n-k,n$不可能同时为奇数，也不可能只有两个偶数，因此只有两种情况，两奇一偶，三偶。</p><p>三者都为偶数时，取整号可以直接拆掉，此时共$n$次对换。</p><p>两个为奇数，一个为偶数时，可将其改写成$[x]=x-{x}$，且此时${x}=\frac{1}{2}$，此时共$n-1$次对换。</p><p>因此至多$n$次对换。</p></blockquote><p>第二问需要借助两个置换群的定理。</p><blockquote><p><strong>定理1</strong>：任何一个<strong>轮换</strong>都可以表示为若干个<strong>对换</strong>的乘积，且<strong>对换数</strong>等于$元素个数-1$。比如：</p><script type="math/tex;mode=display">\left(\begin{matrix}
a&b&c&d&e&f
\end{matrix}\right)=
\left(\begin{matrix}a&b\end{matrix}\right)
\left(\begin{matrix}b&c\end{matrix}\right)
\left(\begin{matrix}c&d\end{matrix}\right)
\left(\begin{matrix}d&e\end{matrix}\right)
\left(\begin{matrix}e&f\end{matrix}\right)</script><p>按从右向左的运算原则，显然有：</p><script type="math/tex;mode=display">f\rightarrow e\rightarrow d\rightarrow c\rightarrow b\rightarrow a=f\rightarrow a</script><p>其他，$e\rightarrow f,d\rightarrow e,…,a\rightarrow b$保持不变，因此定理1成立。</p><p><strong>定理2：</strong>将一个置换分解为不相交轮换的乘积，如果不考虑因子的次序和乘积中1轮换的个数，则这个分解式是唯一的。</p><p>可以将每一个轮换都看作一个圆，这个圆和其他圆不相交，这个圆上的点做任何拓扑上的改变都会导致置换的结果发生变化，因此置换的分解公式是唯一的。</p><p><strong>定理3：</strong>每个置换都可以表示为对换的乘积。</p><p>根据定理2，<strong>每个置换分解为唯一的不相交轮换的乘积</strong>，每个轮换可以分解为对换的乘积。因此每个置换都可以表示为对换的乘积。</p></blockquote><p>下面我们就可以开始证明了：</p><blockquote><p>以下证明默认$nums.length=n$</p><p>证明：我们首先需要证明，对于题目中的全轮换$(123…n)$，当$0&lt;k&lt;n$时，其置换群的轮换表示必定包含$1$到$n$。</p><p>其实就是证明不存在数组某一元素位置没有发生改变，全轮换后，数组下标$i$（假设由1开始）将会变成$(i+k)\%n\neq i$。因此轮换表示必定包含所有元素。</p><p>先将置换分解为不相交轮换的乘积，设不相交轮换数为$i$，又定理1可知，一个轮换可以拆成$元素个数-1$个对换，因此总共有$n-i$个对换。</p><p>由于置换至少可以分解成一个不相交轮换，因此至少$n-1$次对换操作，才能够保证对所有情况都能达到预期效果。</p></blockquote><p>我们可以根据这个思路，将置换群转换为若干个对换的乘积，原则上说，是比翻转算法至少少一次对换。</p><p>当然，如果我们先写出置换群，在分解成轮换群，最后再分解成对换的乘积，这显然是不够效率的，所幸这题是一个全轮换群，全轮换群的乘积是非常容易计算的。</p><p>以下同样默认$nums.length=n$，则其中一个不相连轮换群乘积可表示成：</p><script type="math/tex;mode=display">\begin{matrix}
(1&(1+k)\%n&(1+2k)\%n&...&(1+ik)\%n)
\end{matrix}</script><p>其中，$0&lt;i\leq n$</p><p>我们在进行数组索引的时候，是从$0$开始的，因此，实际写代码的时候也不需要这个恼人的$1$了。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>
       k <span class="token operator">=</span> k<span class="token operator">%</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token class-name">Overlay</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>

   <span class="token punctuation">}</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token class-name">Overlay</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> k<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
       <span class="token keyword">int</span> index1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token keyword">int</span> index2<span class="token operator">=</span>k<span class="token punctuation">;</span>
       <span class="token keyword">int</span> group_amount<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//群元数</span>
       <span class="token keyword">int</span> total_length<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//群元长度</span>
       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length <span class="token operator">&amp;</span> total_length<span class="token operator">&lt;</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
           total_length<span class="token operator">++</span><span class="token punctuation">;</span>
           index1<span class="token operator">=</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
           index2<span class="token operator">=</span><span class="token punctuation">(</span>index1<span class="token operator">+</span>length<span class="token operator">-</span>k<span class="token punctuation">)</span><span class="token operator">%</span>length<span class="token punctuation">;</span>
           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
               <span class="token keyword">if</span><span class="token punctuation">(</span>index2<span class="token operator">==</span>length<span class="token operator">-</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                   group_amount<span class="token operator">++</span><span class="token punctuation">;</span>
                   <span class="token keyword">break</span><span class="token punctuation">;</span>
               <span class="token punctuation">}</span>
               <span class="token function">exchange</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span>index1<span class="token punctuation">,</span>index2<span class="token punctuation">)</span><span class="token punctuation">;</span>
               index1<span class="token operator">=</span>index2<span class="token punctuation">;</span>
               index2<span class="token operator">=</span><span class="token punctuation">(</span>index2<span class="token operator">-</span>k<span class="token operator">+</span>length<span class="token punctuation">)</span><span class="token operator">%</span>length<span class="token punctuation">;</span>
               total_length<span class="token operator">++</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">,</span><span class="token keyword">int</span> j<span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token keyword">int</span> temp<span class="token operator">=</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
       nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
       nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>temp<span class="token punctuation">;</span>
   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们唯一需要注意的也许是实际对换操作的时候，我们是右结合，因此是倒着生成对换群，倒着对换的。</p><p>数组最后一个元素的指标是$n-1$，因此我们还是看到了这个恼人的$1$。</p><p>这其实类似第二种方法，唯一不同的是，第二种方法通过visited数组避免重复索引，在这里，其实就是置换群分解成了多个不相连的轮换群，而我们只在其中一个轮换群中进行轮换。这里的方法是通过索引数组角标，当回到原点的时候，跳出循环。</p><img src="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/image-20230427171208493.png" title="算法评估"><p>好吧，是个负优化。还是跟第二个方法问题一样，索引脚标的时候出现了大量的求余计算。我们为了那一次的对换提升，花费了大量的运算。</p><p>但反过来说，我们从某种程度上证明了，如果我们只通过对换解决这个问题，那么翻转算法速度上就是最优解。因为它至多用了$n$次对换，而理论上限是$n-1$，但$n-1$次对换的算法需要大量求余。</p><h2 id="对换与翻转"><a href="#对换与翻转" class="headerlink" title="对换与翻转"></a>对换与翻转</h2><p>我们刚才说过翻转算法需要$n$或$n-1$次对换，而轮换分解则需要$n-i$次对换。</p><p>很自然我就有一些疑问，这个$i$能不能被事先求出来，他们的对应关系是怎么样的。</p><p>要解答这两个问题首先需要证明在第二个方法中提到的一句话：</p><blockquote><p>如果数组长度length和轮换步长k不互质的话，将会在某一次轮换后回到原点。</p></blockquote><p>事实上这句话的关键在于，如果数组长度length和轮换步长k不互质，那么至少存在两个或以上的不相连轮换群。</p><blockquote><p>以下证明默认$nums.length=n$</p><p>证明：首先根据轮换群乘法，本问题中可能出现的置换群的一个不相连轮换群可表示成：</p><script type="math/tex;mode=display">\begin{matrix}
(1&(1+k)\%n&(1+2k)\%n&...&(1+ik)\%n)
\end{matrix}</script><p>有$((i+1)k)\%n=0$</p><p>这是自然的，因为对于该轮换群，其对换过程为$1\rightarrow (1+k)\%n\rightarrow (1+2k)\%n\rightarrow …\rightarrow (1+ik)\%n\rightarrow 1$</p><p>如果$k$与$n$互质，则当且仅当$i+1=n$时成立，此时该不相连轮换群长度为$n$，已经包含了所有元素。数组中找不出与它不公共的元素，因此它是唯一的不相连轮换群。</p><p>因此当$k$与$n$不互质时，至少存在两个或以上的不相连轮换群。</p></blockquote><p>通过以上的证明我们能感受到，当$0&lt;i\leq n$时，有几个$i$满足$(ik)\%n=0$，置换群就能分解成几个不相连轮换群的乘积。</p><p>但是大家会注意到如果$(jk)\%n=0$，那么$(2jk)\%n=0$同样满足，一直往上，并且$(nk)\%n=0$一定满足。因此$jk$应该是$n$和$k$的最小公倍数。此时，$i={j,2j,…,n-j,n}$，一共有$\frac{n}{j}$个$i$。</p><p>翻转算法到底需要$n$次还是$n-1$次对换，取决于他们的奇偶分布，轮换分解则需要$n-i$次对换，$i$与$n$和$k$的最小公倍数有关，因此两者并不能直接建立起联系。</p><p>但是他们还是有点关系的，参考下面的定理。</p><blockquote><p><strong>定理4</strong>：虽然一个置换表示成对换的个数不唯一，但所用对换个数的奇偶性是唯一的。</p></blockquote><p>翻转算法需要$n$次对换时，$n$和$k$都必须是偶数，此时$n$和$k$不互质，因此存在两个或以上的不相连轮换群，所以$i$必须也会偶数。这样，$n$和$n-i$就都是偶数了。$n-1$次的情况同理。</p></div><hr><div class="reprint" id="reprint-statement"><div class="reprint__author"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-user">文章作者:</i></span> <span class="reprint-info"><a href="/Lillia.github.io/about" rel="external nofollow noreferrer">LYC</a></span></div><div class="reprint__type"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-link">文章链接:</i></span> <span class="reprint-info"><a href="https://yuancongliang.github.io/Lillia.github.io/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/">https://yuancongliang.github.io/Lillia.github.io/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/</a></span></div><div class="reprint__notice"><span class="reprint-meta" style="font-weight:700"><i class="fas fa-copyright">版权声明:</i></span> <span class="reprint-info">本博客所有文章除特別声明外，均采用 <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a> 许可协议。转载请注明来源 <a href="/Lillia.github.io/about" target="_blank">LYC</a> !</span></div></div><script async defer>document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }</script><div class="tag_share" style="display:block"><div class="post-meta__tag-list" style="display:inline-block"><div class="article-tag"><a href="/Lillia.github.io/tags/%E7%BE%A4%E8%AE%BA/"><span class="chip bg-color">群论</span></a> <a href="/Lillia.github.io/tags/%E7%AE%97%E6%B3%95/"><span class="chip bg-color">算法</span></a></div></div><div class="post_share" style="zoom:80%;width:fit-content;display:inline-block;float:right;margin:-.15rem 0"><link rel="stylesheet" href="/Lillia.github.io/libs/share/css/share.min.css"><div id="article-share"><div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div><script src="/Lillia.github.io/libs/share/js/social-share.min.js"></script></div></div></div><div id="reward"><a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a><div id="rewardModal" class="modal"><div class="modal-content"><a class="close modal-close"><i class="fas fa-times"></i></a><h4 class="reward-title">你的赏识是我前进的动力</h4><div class="reward-content"><div class="reward-tabs"><ul class="tabs row"><li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li><li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li></ul><div id="alipay"><img src="/Lillia.github.io/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码"></div><div id="wechat"><img src="/Lillia.github.io/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码"></div></div></div></div></div></div><script>$(function(){$(".tabs").tabs()})</script></div></div><style>.waline-card{margin:1.5rem auto}.waline-card .card-content{padding:20px 20px 5px 20px}#waline p{margin:2px 2px 10px;font-size:1.05rem;line-height:1.78rem}#waline blockquote p{text-indent:.2rem}#waline a{padding:0 2px;color:#4cbf30;font-weight:500;text-decoration:none}#waline img{max-width:100%;cursor:pointer}#waline ol li{list-style-type:decimal}#waline ol,ul{display:block;padding-left:2em;word-spacing:.05rem}#waline ul li,ol li{display:list-item;line-height:1.8rem;font-size:1rem}#waline ul li{list-style-type:disc}#waline ul ul li{list-style-type:circle}#waline table,td,th{padding:12px 13px;border:1px solid #dfe2e5}#waline table,td,th{border:0}table tr:nth-child(2n),thead{background-color:#fafafa}#waline table th{background-color:#f2f2f2;min-width:80px}#waline table td{min-width:80px}#waline h1{font-size:1.85rem;font-weight:700;line-height:2.2rem}#waline h2{font-size:1.65rem;font-weight:700;line-height:1.9rem}#waline h3{font-size:1.45rem;font-weight:700;line-height:1.7rem}#waline h4{font-size:1.25rem;font-weight:700;line-height:1.5rem}#waline h5{font-size:1.1rem;font-weight:700;line-height:1.4rem}#waline h6{font-size:1rem;line-height:1.3rem}#waline p{font-size:1rem;line-height:1.5rem}#waline hr{margin:12px 0;border:0;border-top:1px solid #ccc}#waline blockquote{margin:15px 0;border-left:5px solid #42b983;padding:1rem .8rem .3rem .8rem;color:#666;background-color:rgba(66,185,131,.1)}#waline pre{font-family:monospace,monospace;padding:1.2em;margin:.5em 0;background:#272822;overflow:auto;border-radius:.3em;tab-size:4}#waline code{font-family:monospace,monospace;padding:1px 3px;font-size:.92rem;color:#e96900;background-color:#f8f8f8;border-radius:2px}#waline pre code{font-family:monospace,monospace;padding:0;color:#e8eaf6;background-color:#272822}#waline pre[class*=language-]{padding:1.2em;margin:.5em 0}#waline code[class*=language-],pre[class*=language-]{color:#e8eaf6}#waline [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}#waline b,strong{font-weight:700}#waline dfn{font-style:italic}#waline small{font-size:85%}#waline cite{font-style:normal}#waline mark{background-color:#fcf8e3;padding:.2em}#waline table,td,th{padding:12px 13px;border:1px solid #dfe2e5}table tr:nth-child(2n),thead{background-color:#fafafa}#waline table th{background-color:#f2f2f2;min-width:80px}#waline table td{min-width:80px}#waline [type=checkbox]:not(:checked),[type=checkbox]:checked{position:inherit;margin-left:-1.3rem;margin-right:.4rem;margin-top:-1px;vertical-align:middle;left:unset;visibility:visible}</style><div class="card waline-card" data-aos="fade-up"><div class="comment_headling" style="font-size:20px;font-weight:700;position:relative;padding-left:20px;top:15px;padding-bottom:5px"><i class="fas fa-comments fa-fw" aria-hidden="true"></i> <span>评论</span></div><div id="waline" class="card-content" style="display:grid"></div></div><script src="/Lillia.github.io/libs/waline/Waline.min.js"></script><script>new Waline({el:"#waline",serverURL:"https://waline-comment-ftvhqdtn7-diduseemyelk.vercel.app/",avatar:"mm"})</script><article id="prenext-posts" class="prev-next articles"><div class="row article-row"><div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up"><div class="article-badge left-badge text-color"><i class="far fa-dot-circle"></i> &nbsp;本篇</div><div class="card"><a href="/Lillia.github.io/2023/04/17/yi-dao-ke-yi-yong-qun-lun-de-suan-fa/"><div class="card-image"><img src="/Lillia.github.io/medias/featureimages/19.jpg" class="responsive-img" alt="一道可以用群论的算法"> <span class="card-title">一道可以用群论的算法</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-04-17</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/Lillia.github.io/categories/%E7%BE%A4%E8%AE%BA/" class="post-category">群论</a></span></div></div><div class="card-action article-tags"><a href="/Lillia.github.io/tags/%E7%BE%A4%E8%AE%BA/"><span class="chip bg-color">群论</span></a> <a href="/Lillia.github.io/tags/%E7%AE%97%E6%B3%95/"><span class="chip bg-color">算法</span></a></div></div></div><div class="article col s12 m6" data-aos="fade-up"><div class="article-badge right-badge text-color">下一篇&nbsp;<i class="fas fa-chevron-right"></i></div><div class="card"><a href="/Lillia.github.io/2023/02/18/ji-lu-xia-tensorrt-de-bu-shu/"><div class="card-image"><img src="/Lillia.github.io/medias/featureimages/3.jpg" class="responsive-img" alt="记录下tensorRT的部署"> <span class="card-title">记录下tensorRT的部署</span></div></a><div class="card-content article-content"><div class="summary block-with-text"></div><div class="publish-info"><span class="publish-date"><i class="far fa-clock fa-fw icon-date"></i> 2023-02-18</span><span class="publish-author"><i class="fas fa-bookmark fa-fw icon-category"></i> <a href="/Lillia.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/" class="post-category">深度学习</a></span></div></div><div class="card-action article-tags"><a href="/Lillia.github.io/tags/blog/"><span class="chip bg-color">blog</span></a> <a href="/Lillia.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="chip bg-color">深度学习</span></a> <a href="/Lillia.github.io/tags/TensorRT/"><span class="chip bg-color">TensorRT</span></a></div></div></div></div></article></div><script src="/Lillia.github.io/libs/codeBlock/codeBlockFuction.js"></script><script src="/Lillia.github.io/libs/prism/prism.min.js"></script><script src="/Lillia.github.io/libs/codeBlock/codeLang.js"></script><script src="/Lillia.github.io/libs/codeBlock/codeCopy.js"></script><script src="/Lillia.github.io/libs/codeBlock/codeShrink.js"></script></div><div id="toc-aside" class="expanded col l3 hide-on-med-and-down"><div class="toc-widget card" style="background-color:#fff"><div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div><div id="toc-content"></div></div></div></div><div id="floating-toc-btn" class="hide-on-med-and-down"><a class="btn-floating btn-large bg-color"><i class="fas fa-list-ul"></i></a></div><script src="/Lillia.github.io/libs/tocbot/tocbot.min.js"></script><script>$(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });</script></main><footer class="page-footer bg-color"><div class="container row center-align" style="margin-bottom:15px!important"><div class="col s12 m8 l8 copy-right">Copyright&nbsp;&copy; <span id="year">2022-2023</span> <a href="/Lillia.github.io/about" target="_blank">LYC</a> |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a> |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a><br>&nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span class="white-color">16k</span> <span id="busuanzi_container_site_pv">&nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv" class="white-color"></span></span> <span id="busuanzi_container_site_uv">&nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv" class="white-color"></span></span><br><span id="sitetime">Loading ...</span><script>var calcSiteTime=function(){var e=new Date,t="2022",n=e.getFullYear(),i=e.getMonth()+1,a=e.getDate(),r=e.getHours(),s=e.getMinutes(),o=e.getSeconds(),g=Date.UTC(t,"12","11","0","0","0"),d=Date.UTC(n,i,a,r,s,o)-g,m=Math.floor(d/31536e6),l=Math.floor(d/864e5-365*m);if(t===String(n)){document.getElementById("year").innerHTML=n;var c="This site has been running for "+l+" days";c="本站已运行 "+l+" 天",document.getElementById("sitetime").innerHTML=c}else{document.getElementById("year").innerHTML=t+" - "+n;var u="This site has been running for "+m+" years and "+l+" days";u="本站已运行 "+m+" 年 "+l+" 天",document.getElementById("sitetime").innerHTML=u}};calcSiteTime()</script><br></div><div class="col s12 m4 l4 social-link social-statis"><a href="https://github.com/YuancongLiang" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50"><i class="fab fa-github"></i></a><a href="mailto:e1kovo@stu2019.jnu.edu.cn" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50"><i class="fas fa-envelope-open"></i></a><a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1035603730" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1035603730" data-position="top" data-delay="50"><i class="fab fa-qq"></i></a><a href="https://weibo.com/5602005765" class="tooltipped" target="_blank" data-tooltip="关注我的微博" data-position="top" data-delay="50"><i class="fab fa-weibo"></i></a> <a href="https://www.zhihu.com/people/candyseven-50" class="tooltipped" target="_blank" data-tooltip="关注我的知乎" data-position="top" data-delay="50"><i class="fab fa-zhihu1">知</i></a><a href="/Lillia.github.io/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50"><i class="fas fa-rss"></i></a></div></div></footer><div class="progress-bar"></div><div id="searchModal" class="modal"><div class="modal-content"><div class="search-header"><span class="title"><i class="fas fa-search"></i> &nbsp;&nbsp;搜索</span> <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字" class="search-input"></div><div id="searchResult"></div></div></div><script>$(function(){!function(t,i,a){"use strict";$.ajax({url:t,dataType:"xml",success:function(t){var e=$("entry",t).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),r=document.getElementById(i),n=document.getElementById(a);r.addEventListener("input",function(){var f='<ul class="search-result-list">',m=this.value.trim().toLowerCase().split(/[\s\-]+/);n.innerHTML="",this.value.trim().length<=0||(e.forEach(function(t){var r=!0,n=t.title.trim().toLowerCase(),i=t.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),e=t.url;e=0===e.indexOf("/")?t.url:"/"+e;var a=-1,s=-1,l=-1;if(""!==n&&""!==i&&m.forEach(function(t,e){a=n.indexOf(t),s=i.indexOf(t),a<0&&s<0?r=!1:(s<0&&(s=0),0===e&&(l=s))}),r){f+="<li><a href='"+e+"' class='search-result-title'>"+n+"</a>";var c=t.content.trim().replace(/<[^>]+>/g,"");if(0<=l){var u=l-20,o=l+80;u<0&&(u=0),0===u&&(o=100),o>c.length&&(o=c.length);var h=c.substr(u,o);m.forEach(function(t){var e=new RegExp(t,"gi");h=h.replace(e,'<em class="search-keyword">'+t+"</em>")}),f+='<p class="search-result">'+h+"...</p>"}f+="</li>"}}),f+="</ul>",n.innerHTML=f)})}})}("/Lillia.github.io/search.xml","searchInput","searchResult")})</script><div class="stars-con"><div id="stars"></div><div id="stars2"></div><div id="stars3"></div></div><script>function switchNightMode(){$('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($("body")),setTimeout(function(){$("body").hasClass("DarkMode")?($("body").removeClass("DarkMode"),localStorage.setItem("isDark","0"),$("#sum-moon-icon").removeClass("fa-sun").addClass("fa-moon")):($("body").addClass("DarkMode"),localStorage.setItem("isDark","1"),$("#sum-moon-icon").addClass("fa-sun").removeClass("fa-moon")),setTimeout(function(){$(".Cuteen_DarkSky").fadeOut(1e3,function(){$(this).remove()})},2e3)})}</script><div id="backTop" class="top-scroll"><a class="btn-floating btn-large waves-effect waves-light" href="#!"><i class="fas fa-arrow-up"></i></a></div><script src="/Lillia.github.io/libs/materialize/materialize.min.js"></script><script src="/Lillia.github.io/libs/masonry/masonry.pkgd.min.js"></script><script src="/Lillia.github.io/libs/aos/aos.js"></script><script src="/Lillia.github.io/libs/scrollprogress/scrollProgress.min.js"></script><script src="/Lillia.github.io/libs/lightGallery/js/lightgallery-all.min.js"></script><script src="/Lillia.github.io/js/matery.js"></script><script src="https://yuancongliang.github.io/Lillia.github.io/live2d-widget/autoload.js"></script><script src="https://ssl.captcha.qq.com/TCaptcha.js"></script><script src="/Lillia.github.io/libs/others/TencentCaptcha.js"></script><button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><script src="/Lillia.github.io/libs/others/clicklove.js" async></script><script async src="/Lillia.github.io/libs/others/busuanzi.pure.mini.js"></script><div style="position:fixed;bottom:125px;right:16px;cursor:pointer"><a title="兔小巢" target="_blank" rel="noopener" href="https://support.qq.com/products/491953"><i class="fa fa-comments fa-3x" aria-hidden="true"></i></a></div><script src="/Lillia.github.io/libs/instantpage/instantpage.js" type="module"></script></body></html>